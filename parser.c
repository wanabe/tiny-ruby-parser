/* A packrat parser generated by PackCR 0.0.8 */

/* original file: https://git.ruby-lang.org/ruby.git/tree/parse.y */

#ifdef _MSC_VER
#undef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif /* _MSC_VER */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef _MSC_VER
#if defined __GNUC__ && defined _WIN32 /* MinGW */
#ifndef PACKCR_USE_SYSTEM_STRNLEN
#define strnlen(str, maxlen) packcr_strnlen(str, maxlen)
static size_t packcr_strnlen(const char *str, size_t maxlen) {
    size_t i;
    for (i = 0; i < maxlen && str[i]; i++);
    return i;
}
#endif /* !PACKCR_USE_SYSTEM_STRNLEN */
#endif /* defined __GNUC__ && defined _WIN32 */
#endif /* !_MSC_VER */

#include "parser.h"

    static inline void packcr_location_init(packcr_location_t *lp) {
        lp->lineno = 0;
        lp->column = 0;
    }

    static inline void packcr_location_forward(packcr_location_t *lp, char *buf, size_t n) {
        size_t i = 0;
        for (; i < n; i++) {
            if (buf[i] == '\n') {
                lp->column = 0;
                lp->lineno++;
            } else {
                lp->column++;
            }
        }
    }

    static inline packcr_location_t packcr_location_add(packcr_location_t l1, packcr_location_t l2) {
        packcr_location_t l = { l1.lineno + l2.lineno, l2.column };
        if (l2.lineno == 0) {
          l.column += l1.column;
        }
        return l;
    }

    static inline packcr_location_t packcr_location_sub(packcr_location_t l1, packcr_location_t l2) {
        packcr_location_t l = { l1.lineno - l2.lineno, l1.column - l2.column };
        return l;
    }

#define PACKCR_GETCHAR(auxil) tiny_ruby_parser_getchar()

int tiny_ruby_parser_getchar(void) {
    VALUE rstdin = rb_gv_get("$stdin");
    VALUE rchar = rb_funcall(rstdin, rb_intern("getc"), 0);
    if (NIL_P(rchar)) return -1;
    return NUM2INT(rb_funcall(rchar, rb_intern("ord"), 0));
}

static const rb_code_location_t NULL_LOC = { {0, -1}, {0, -1} };
VALUE tiny_ruby_parser_cstr2num(const char *str, int base) {
    char *ptr;
    long v = 0;
    for (ptr = (char*)str; *ptr; ptr++) {
        const char c = *ptr;
        if (c >= '0' && c <= '9') {
            v = v * base + c - '0';
        } else if (c >= 'a' && c <= 'z') {
            v = v * base + c - 'a' + 10;
        } else if (c >= 'A' && c <= 'Z') {
            v = v * base + c - 'A' + 10;
        }
    }
    return LONG2NUM(v);
}

static int global_node_id = 0;

NODE *tiny_ruby_parser_newnode(enum node_type type, VALUE a0, VALUE a1, VALUE a2, const rb_code_position_t beg_pos, const rb_code_position_t end_pos) {
    NODE *node = (NODE*)malloc(sizeof(NODE));
    node->type = type;
    node->u1.value = a0;
    node->u2.value = a1;
    node->u3.value = a2;
    node->nd_loc.beg_pos = beg_pos;
    node->nd_loc.end_pos = end_pos;
    node->nd_loc.lineno = beg_pos.lineno;
    node->node_id = global_node_id++;
    node->newline = 0;
    node->var_table = Qnil;
    return node;
}

NODE *tiny_ruby_parser_block_append(NODE *head, NODE *tail) {
    NODE *h = head, *end;
    if (tail == 0) return head;
    if (head == 0) return tail;
    switch (head->type) {
      case NODE_LIT:
      case NODE_STR:
        return tail;
      case NODE_BLOCK:
        end = head->nd_end;
        break;
      default:
        h = end = NEW_NODE(NODE_BLOCK, head, 0, 0, head->nd_loc.beg_pos, head->nd_loc.end_pos);
        end->var_table = head->var_table;
        end->nd_end = end;
        head = end;
    }
    if (tail->type != NODE_BLOCK) {
        tail = NEW_NODE(NODE_BLOCK, tail, 0, 0, tail->nd_loc.beg_pos, tail->nd_loc.end_pos);
        tail->nd_end = tail;
    }
    end->nd_next = tail;
    h->nd_end = tail->nd_end;
    head->nd_loc.end_pos = tail->nd_loc.end_pos;
    return head;
}

NODE *tiny_ruby_parser_list_append(NODE *list, NODE *item) {
  NODE *last;

  if (list == 0) return NEW_NODE(NODE_LIST, item, 1, 0, item->nd_loc.beg_pos, item->nd_loc.end_pos);
  if (list->nd_next) {
     last = list->nd_next->nd_end;
  } else {
      last = list;
  }

  list->nd_alen += 1;
  last->nd_next = NEW_NODE(NODE_LIST, item, 1, 0, item->nd_loc.beg_pos, item->nd_loc.end_pos);
  list->nd_next->nd_end = last->nd_next;

  list->nd_loc.end_pos = item->nd_loc.end_pos;

  return list;
}

void tiny_ruby_parser_var_table_add(NODE *node, VALUE sym) {
    if (NIL_P(node->var_table)) {
        node->var_table = rb_ary_new();
    }
    rb_ary_push(node->var_table, sym);
}

void tiny_ruby_parser_var_table_pass(NODE *dst, NODE *src) {
    if (!src) {
        return;
    }
    if (!NIL_P(src->var_table)) {
        if (NIL_P(dst->var_table)) {
            dst->var_table = src->var_table;
        } else {
            rb_ary_concat(dst->var_table, src->var_table);
        }
    }
    src->var_table = Qnil;
}

NODE *tiny_ruby_parser_set_defun_body(NODE *n, NODE *args, NODE *body, const rb_code_position_t beg_pos, const rb_code_position_t end_pos) {
    VALUE tbl;
    tiny_ruby_parser_var_table_pass(args, body);
    tbl = args->var_table;
    if (NIL_P(tbl)) {
        tbl = rb_ary_new();
    }
    n->nd_defn = NEW_NODE(NODE_SCOPE, tbl, body, args, beg_pos, end_pos);
    args->var_table = Qnil;
    n->nd_loc.beg_pos = beg_pos;
    n->nd_loc.end_pos = end_pos;
    return n;
}

VALUE tiny_ruby_parser_i_inspect(RB_BLOCK_CALL_FUNC_ARGLIST(item, dummy)) {
    return rb_inspect(item);
}

void tiny_ruby_parser_dump_node(NODE *node, VALUE indent) {
    printf("%s", RSTRING_PTR(indent));
    if (node == 0) {
        printf("(null node)\n");
        return;
    }
    printf("@ ");
    switch(node->type) {
#define nt(t) \
      case t: \
        printf(#t);\
        break
      nt(NODE_SCOPE);
      nt(NODE_LIT);
      nt(NODE_STR);
      nt(NODE_LIST);
      nt(NODE_FCALL);
      nt(NODE_OPCALL);
      nt(NODE_QCALL);
      nt(NODE_CALL);
      nt(NODE_BLOCK);
      nt(NODE_DEFN);
      nt(NODE_ARGS);
      nt(NODE_LASGN);
      nt(NODE_BEGIN);
      nt(NODE_CLASS);
      nt(NODE_COLON2);
#undef nt
      default:
        printf("(INVALID TYPE: %ld)", node->type);
    }
    printf(" (id: %d, line: %ld, location: (%ld,%ld)-(%ld,%ld))",
        node->node_id, node->nd_loc.lineno + 1,
        node->nd_loc.beg_pos.lineno + 1, node->nd_loc.beg_pos.column,
        node->nd_loc.end_pos.lineno + 1, node->nd_loc.end_pos.column
    );
    if(node->newline) {
        printf("*");
    }
    printf("\n");
    switch(node->type) {
      case NODE_SCOPE:
        printf("%s+- nd_tbl: ", RSTRING_PTR(indent));
        fflush(stdout);
        if (!node->u1.value || NIL_P(node->u1.value) || RARRAY_LEN(node->u1.value) == 0) {
            printf("(empty)\n");
        } else {
            VALUE strs = rb_block_call(node->u1.value, rb_intern("map"), 0, NULL,tiny_ruby_parser_i_inspect, Qnil);
            VALUE str = rb_funcall(strs, rb_intern("join"), 1, rb_str_new_cstr(","));
            rb_funcall(rb_mKernel, rb_intern("puts"), 1, str);
            rb_funcall(rb_const_get(rb_mKernel, rb_intern("STDOUT")), rb_intern("flush"), 0);
        }
        printf("%s+- nd_args:\n", RSTRING_PTR(indent));
        rb_str_cat(indent, "|   ", 4);
        tiny_ruby_parser_dump_node(node->nd_args, indent);
        rb_str_resize(indent, RSTRING_LEN(indent) - 4);
        printf("%s+- nd_body:\n", RSTRING_PTR(indent));
        rb_str_cat(indent, "    ", 4);
        tiny_ruby_parser_dump_node(node->u2.node, indent);
        rb_str_resize(indent, RSTRING_LEN(indent) - 4);
        break;
      case NODE_LIT:
      case NODE_STR:
        printf("%s+- nd_lit: ", RSTRING_PTR(indent));
        fflush(stdout);
        rb_p(node->u1.value);
        rb_funcall(rb_const_get(rb_mKernel, rb_intern("STDOUT")), rb_intern("flush"), 0);
        break;
      case NODE_FCALL:
        printf("%s+- nd_mid: ", RSTRING_PTR(indent));
        fflush(stdout);
        rb_p(node->u2.value);
        rb_funcall(rb_const_get(rb_mKernel, rb_intern("STDOUT")), rb_intern("flush"), 0);
        printf("%s+- nd_args:\n", RSTRING_PTR(indent));
        rb_str_cat(indent, "    ", 4);
        tiny_ruby_parser_dump_node(node->u3.node, indent);
        rb_str_resize(indent, RSTRING_LEN(indent) - 4);
        break;
      case NODE_OPCALL:
      case NODE_CALL:
      case NODE_QCALL:
        printf("%s+- nd_mid: ", RSTRING_PTR(indent));
        fflush(stdout);
        rb_p(node->u2.value);
        rb_funcall(rb_const_get(rb_mKernel, rb_intern("STDOUT")), rb_intern("flush"), 0);
        printf("%s+- nd_recv:\n", RSTRING_PTR(indent));
        rb_str_cat(indent, "|   ", 4);
        tiny_ruby_parser_dump_node(node->u1.node, indent);
        rb_str_resize(indent, RSTRING_LEN(indent) - 4);
        printf("%s+- nd_args:\n", RSTRING_PTR(indent));
        rb_str_cat(indent, "    ", 4);
        tiny_ruby_parser_dump_node(node->u3.node, indent);
        rb_str_resize(indent, RSTRING_LEN(indent) - 4);
        break;
      case NODE_LIST:
        printf("%s+- nd_alen: %ld\n", RSTRING_PTR(indent), node->u2.argc);
        {
            NODE *n;
            for (n = node; n; n = n->nd_next) {
                printf("%s+- nd_head:\n", RSTRING_PTR(indent));
                rb_str_cat(indent, "|   ", 4);
                tiny_ruby_parser_dump_node(n->u1.node, indent);
                rb_str_resize(indent, RSTRING_LEN(indent) - 4);
            }
        }
        printf("%s+- nd_next:\n", RSTRING_PTR(indent));
        printf("%s    (null node)\n", RSTRING_PTR(indent));
        break;
      case NODE_BLOCK:
        {
            NODE *n;
            int i;
            VALUE child_indent = rb_str_cat(rb_str_dup(indent), "|   ", 4);
            for (n = node, i = 1; n; i++, n = n->nd_next) {
                printf("%s+- nd_head (%d):\n", RSTRING_PTR(indent), i);
                if (n == node->nd_end) {
                    child_indent = rb_str_cat(rb_str_dup(indent), "    ", 4);
                }
                tiny_ruby_parser_dump_node(n->nd_head, child_indent);
            }
        }
        break;
      case NODE_DEFN:
        printf("%s+- nd_mid: ", RSTRING_PTR(indent));
        fflush(stdout);
        rb_p(node->u2.value);
        rb_funcall(rb_const_get(rb_mKernel, rb_intern("STDOUT")), rb_intern("flush"), 0);
        printf("%s+- nd_defn:\n", RSTRING_PTR(indent));
        rb_str_cat(indent, "    ", 4);
        tiny_ruby_parser_dump_node(node->nd_defn, indent);
        rb_str_resize(indent, RSTRING_LEN(indent) - 4);
        break;
      case NODE_ARGS:
        printf("%s+- nd_ainfo->pre_args_num: %d\n", RSTRING_PTR(indent), node->nd_ainfo->pre_args_num);
        printf("%s+- nd_ainfo->pre_init:\n", RSTRING_PTR(indent));
        printf("%s|   (null node)\n", RSTRING_PTR(indent));
        printf("%s+- nd_ainfo->post_args_num: 0\n", RSTRING_PTR(indent));
        printf("%s+- nd_ainfo->post_init:\n", RSTRING_PTR(indent));
        printf("%s|   (null node)\n", RSTRING_PTR(indent));
        printf("%s+- nd_ainfo->first_post_arg: (null)\n", RSTRING_PTR(indent));
        printf("%s+- nd_ainfo->rest_arg: (null)\n", RSTRING_PTR(indent));
        printf("%s+- nd_ainfo->block_arg: (null)\n", RSTRING_PTR(indent));
        printf("%s+- nd_ainfo->opt_args:\n", RSTRING_PTR(indent));
        printf("%s|   (null node)\n", RSTRING_PTR(indent));
        printf("%s+- nd_ainfo->kw_args:\n", RSTRING_PTR(indent));
        printf("%s|   (null node)\n", RSTRING_PTR(indent));
        printf("%s+- nd_ainfo->kw_rest_arg:\n", RSTRING_PTR(indent));
        printf("%s    (null node)\n", RSTRING_PTR(indent));
        break;
      case NODE_LASGN:
        printf("%s+- nd_vid: ", RSTRING_PTR(indent));
        fflush(stdout);
        rb_p(node->nd_vid);
        rb_funcall(rb_const_get(rb_mKernel, rb_intern("STDOUT")), rb_intern("flush"), 0);
        printf("%s+- nd_value:\n", RSTRING_PTR(indent));
        rb_str_cat(indent, "    ", 4);
        tiny_ruby_parser_dump_node(node->nd_value, indent);
        rb_str_resize(indent, RSTRING_LEN(indent) - 4);
        break;
      case NODE_BEGIN:
        printf("%s+- nd_body:\n", RSTRING_PTR(indent));
        rb_str_cat(indent, "    ", 4);
        tiny_ruby_parser_dump_node(node->u2.node, indent);
        rb_str_resize(indent, RSTRING_LEN(indent) - 4);
        break;
      case NODE_CLASS:
        printf("%s+- nd_cpath:\n", RSTRING_PTR(indent));
        rb_str_cat(indent, "|   ", 4);
        tiny_ruby_parser_dump_node(node->nd_cpath, indent);
        rb_str_resize(indent, RSTRING_LEN(indent) - 4);
        printf("%s+- nd_super:\n", RSTRING_PTR(indent));
        rb_str_cat(indent, "|   ", 4);
        tiny_ruby_parser_dump_node(node->nd_super, indent);
        rb_str_resize(indent, RSTRING_LEN(indent) - 4);
        printf("%s+- nd_body:\n", RSTRING_PTR(indent));
        rb_str_cat(indent, "        ", 4);
        tiny_ruby_parser_dump_node(node->u2.node, indent);
        rb_str_resize(indent, RSTRING_LEN(indent) - 4);
        break;
      case NODE_COLON2:
        printf("%s+- nd_mid: ", RSTRING_PTR(indent));
        fflush(stdout);
        rb_p(node->u2.value);
        rb_funcall(rb_const_get(rb_mKernel, rb_intern("STDOUT")), rb_intern("flush"), 0);
        printf("%s+- nd_head:\n", RSTRING_PTR(indent));
        rb_str_cat(indent, "    ", 4);
        tiny_ruby_parser_dump_node(node->u1.node, indent);
        rb_str_resize(indent, RSTRING_LEN(indent) - 4);
    }
}
#if !defined __has_attribute || defined _MSC_VER
#define __attribute__(x)
#endif

#ifdef _MSC_VER
#define MARK_FUNC_AS_USED __pragma(warning(suppress:4505))
#else
#define MARK_FUNC_AS_USED __attribute__((__unused__))
#endif

#ifndef PACKCR_BUFFER_MIN_SIZE
#define PACKCR_BUFFER_MIN_SIZE 256
#endif /* !PACKCR_BUFFER_MIN_SIZE */

#ifndef PACKCR_ARRAY_MIN_SIZE
#define PACKCR_ARRAY_MIN_SIZE 2
#endif /* !PACKCR_ARRAY_MIN_SIZE */

#ifndef PACKCR_POOL_MIN_SIZE
#define PACKCR_POOL_MIN_SIZE 65536
#endif /* !PACKCR_POOL_MIN_SIZE */

#define PACKCR_DBG_EVALUATE 0
#define PACKCR_DBG_MATCH    1
#define PACKCR_DBG_NOMATCH  2

#define PACKCR_VOID_VALUE (~(size_t)0)

typedef enum packcr_bool_tag {
    PACKCR_FALSE = 0,
    PACKCR_TRUE
} packcr_bool_t;

typedef struct packcr_char_array_tag {
    char *buf;
    size_t max;
    size_t len;
} packcr_char_array_t;

typedef struct packcr_range_tag {
    size_t start;
    size_t end;
    packcr_location_t start_loc;
    packcr_location_t end_loc;
} packcr_range_t;

typedef tiny_ruby_value packcr_value_t;

typedef tiny_ruby_context_ext *packcr_auxil_t;

typedef tiny_ruby_parser_context_t packcr_context_t;

typedef struct packcr_value_table_tag {
    packcr_value_t *buf;
    size_t max;
    size_t len;
} packcr_value_table_t;

typedef struct packcr_value_refer_table_tag {
    packcr_value_t **buf;
    size_t max;
    size_t len;
} packcr_value_refer_table_t;

typedef struct packcr_capture_tag {
    packcr_range_t range;
    char *string; /* mutable */
} packcr_capture_t;

typedef struct packcr_capture_table_tag {
    packcr_capture_t *buf;
    size_t max;
    size_t len;
} packcr_capture_table_t;

typedef struct packcr_capture_const_table_tag {
    const packcr_capture_t **buf;
    size_t max;
    size_t len;
} packcr_capture_const_table_t;

typedef struct packcr_thunk_tag packcr_thunk_t;
typedef struct packcr_thunk_array_tag packcr_thunk_array_t;

typedef void (*packcr_action_t)(packcr_context_t *, packcr_thunk_t *, packcr_value_t *);

typedef enum packcr_thunk_type_tag {
    PACKCR_THUNK_LEAF,
    PACKCR_THUNK_NODE
} packcr_thunk_type_t;

typedef struct packcr_thunk_leaf_tag {
    packcr_value_refer_table_t values;
    packcr_capture_const_table_t capts;
    packcr_capture_t capt0;
    packcr_action_t action;
} packcr_thunk_leaf_t;

typedef struct packcr_thunk_node_tag {
    const packcr_thunk_array_t *thunks; /* just a reference */
    packcr_value_t *value; /* just a reference */
} packcr_thunk_node_t;

typedef union packcr_thunk_data_tag {
    packcr_thunk_leaf_t leaf;
    packcr_thunk_node_t node;
} packcr_thunk_data_t;

struct packcr_thunk_tag {
    packcr_thunk_type_t type;
    packcr_thunk_data_t data;
};

struct packcr_thunk_array_tag {
    packcr_thunk_t **buf;
    size_t max;
    size_t len;
};

typedef struct packcr_thunk_chunk_tag {
    packcr_value_table_t values;
    packcr_capture_table_t capts;
    packcr_thunk_array_t thunks;
    size_t pos; /* the starting position in the character buffer */
    packcr_location_t pos_loc;
} packcr_thunk_chunk_t;

typedef struct packcr_lr_memo_tag packcr_lr_memo_t;

struct packcr_lr_memo_tag {
    size_t offset;
    packcr_location_t offset_loc;
    packcr_lr_memo_t *hold;
    packcr_thunk_chunk_t *chunk;
    packcr_bool_t fail;
    packcr_bool_t grow;
};

typedef struct packcr_rule_set_tag packcr_rule_set_t;

typedef packcr_thunk_chunk_t *(*packcr_rule_t)(packcr_context_t *, size_t, packcr_location_t, packcr_rule_set_t*);

typedef struct packcr_rule_set_tag {
    packcr_rule_t *buf;
    size_t max;
    size_t len;
} packcr_rule_set_t;

typedef struct packcr_lr_memo_map_entry_tag {
    packcr_rule_t rule;
    packcr_lr_memo_t *memo;
} packcr_lr_memo_map_entry_t;

typedef struct packcr_lr_memo_map_tag {
    packcr_lr_memo_map_entry_t *buf;
    size_t max;
    size_t len;
} packcr_lr_memo_map_t;

typedef struct packcr_lr_table_tag {
    packcr_lr_memo_map_t **buf;
    size_t max;
    size_t len;
    size_t ofs;
} packcr_lr_table_t;

typedef struct packcr_memory_entry_tag packcr_memory_entry_t;
typedef struct packcr_memory_pool_tag packcr_memory_pool_t;

struct packcr_memory_entry_tag {
    packcr_memory_entry_t *next;
};

struct packcr_memory_pool_tag {
    packcr_memory_pool_t *next;
    size_t allocated;
    size_t unused;
};

typedef struct packcr_memory_recycler_tag {
    packcr_memory_pool_t *pool_list;
    packcr_memory_entry_t *entry_list;
    size_t element_size;
} packcr_memory_recycler_t;

struct tiny_ruby_parser_context_tag {
    size_t buffer_start_position; /* the position in the input of the first character currently buffered */
    size_t position_offset; /* the current parsing position in the character buffer */
    packcr_location_t buffer_start_position_loc;
    packcr_location_t position_offset_loc;
    size_t level;
    packcr_char_array_t buffer;
    packcr_lr_table_t lrtable;
    packcr_thunk_array_t thunks;
    packcr_auxil_t auxil;
    packcr_memory_recycler_t thunk_chunk_recycler;
    packcr_memory_recycler_t lr_memo_recycler;
};

#ifndef PACKCR_ERROR
#define PACKCR_ERROR(auxil) packcr_error()
MARK_FUNC_AS_USED
static void packcr_error(void) {
    fprintf(stderr, "Syntax error\n");
    exit(1);
}
#endif /* !PACKCR_ERROR */

#ifndef PACKCR_GETCHAR
#define PACKCR_GETCHAR(auxil) getchar()
#endif /* !PACKCR_GETCHAR */

#ifndef PACKCR_MALLOC
#define PACKCR_MALLOC(auxil, size) packcr_malloc_e(size)
static void *packcr_malloc_e(size_t size) {
    void *const p = malloc(size);
    if (p == NULL) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }
    return p;
}
#endif /* !PACKCR_MALLOC */

#ifndef PACKCR_REALLOC
#define PACKCR_REALLOC(auxil, ptr, size) packcr_realloc_e(ptr, size)
static void *packcr_realloc_e(void *ptr, size_t size) {
    void *const p = realloc(ptr, size);
    if (p == NULL) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }
    return p;
}
#endif /* !PACKCR_REALLOC */

#ifndef PACKCR_FREE
#define PACKCR_FREE(auxil, ptr) free(ptr)
#endif /* !PACKCR_FREE */

#ifndef PACKCR_DEBUG
#define PACKCR_DEBUG(auxil, event, rule, level, pos, buffer, length) ((void)0)
#endif /* !PACKCR_DEBUG */

static char *packcr_strndup_e(packcr_auxil_t auxil, const char *str, size_t len) {
    const size_t m = strnlen(str, len);
    char *const s = (char *)PACKCR_MALLOC(auxil, m + 1);
    memcpy(s, str, m);
    s[m] = '\0';
    return s;
}

static void packcr_char_array__init(packcr_auxil_t auxil, packcr_char_array_t *array) {
    array->len = 0;
    array->max = 0;
    array->buf = NULL;
}

static void packcr_char_array__add(packcr_auxil_t auxil, packcr_char_array_t *array, char ch) {
    if (array->max <= array->len) {
        const size_t n = array->len + 1;
        size_t m = array->max;
        if (m == 0) m = PACKCR_BUFFER_MIN_SIZE;
        while (m < n && m != 0) m <<= 1;
        if (m == 0) m = n;
        array->buf = (char *)PACKCR_REALLOC(auxil, array->buf, m);
        array->max = m;
    }
    array->buf[array->len++] = ch;
}

static void packcr_char_array__term(packcr_auxil_t auxil, packcr_char_array_t *array) {
    PACKCR_FREE(auxil, array->buf);
}

static void packcr_value_table__init(packcr_auxil_t auxil, packcr_value_table_t *table) {
    table->len = 0;
    table->max = 0;
    table->buf = NULL;
}

MARK_FUNC_AS_USED
static void packcr_value_table__resize(packcr_auxil_t auxil, packcr_value_table_t *table, size_t len) {
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = PACKCR_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (packcr_value_t *)PACKCR_REALLOC(auxil, table->buf, sizeof(packcr_value_t) * m);
        table->max = m;
    }
    table->len = len;
}

MARK_FUNC_AS_USED
static void packcr_value_table__clear(packcr_auxil_t auxil, packcr_value_table_t *table) {
    memset(table->buf, 0, sizeof(packcr_value_t) * table->len);
}

static void packcr_value_table__term(packcr_auxil_t auxil, packcr_value_table_t *table) {
    PACKCR_FREE(auxil, table->buf);
}

static void packcr_value_refer_table__init(packcr_auxil_t auxil, packcr_value_refer_table_t *table) {
    table->len = 0;
    table->max = 0;
    table->buf = NULL;
}

static void packcr_value_refer_table__resize(packcr_auxil_t auxil, packcr_value_refer_table_t *table, size_t len) {
    size_t i;
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = PACKCR_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (packcr_value_t **)PACKCR_REALLOC(auxil, table->buf, sizeof(packcr_value_t *) * m);
        table->max = m;
    }
    for (i = table->len; i < len; i++) table->buf[i] = NULL;
    table->len = len;
}

static void packcr_value_refer_table__term(packcr_auxil_t auxil, packcr_value_refer_table_t *table) {
    PACKCR_FREE(auxil, table->buf);
}

static void packcr_capture_table__init(packcr_auxil_t auxil, packcr_capture_table_t *table) {
    table->len = 0;
    table->max = 0;
    table->buf = NULL;
}

MARK_FUNC_AS_USED
static void packcr_capture_table__resize(packcr_auxil_t auxil, packcr_capture_table_t *table, size_t len) {
    size_t i;
    for (i = len; i < table->len; i++) PACKCR_FREE(auxil, table->buf[i].string);
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = PACKCR_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (packcr_capture_t *)PACKCR_REALLOC(auxil, table->buf, sizeof(packcr_capture_t) * m);
        table->max = m;
    }
    for (i = table->len; i < len; i++) {
        table->buf[i].range.start = 0;
        table->buf[i].range.end = 0;
        packcr_location_init(&table->buf[i].range.start_loc);
        packcr_location_init(&table->buf[i].range.end_loc);
        table->buf[i].string = NULL;
    }
    table->len = len;
}

static void packcr_capture_table__term(packcr_auxil_t auxil, packcr_capture_table_t *table) {
    while (table->len > 0) {
        table->len--;
        PACKCR_FREE(auxil, table->buf[table->len].string);
    }
    PACKCR_FREE(auxil, table->buf);
}

static void packcr_capture_const_table__init(packcr_auxil_t auxil, packcr_capture_const_table_t *table) {
    table->len = 0;
    table->max = 0;
    table->buf = NULL;
}

static void packcr_capture_const_table__resize(packcr_auxil_t auxil, packcr_capture_const_table_t *table, size_t len) {
    size_t i;
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = PACKCR_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (const packcr_capture_t **)PACKCR_REALLOC(auxil, (packcr_capture_t **)table->buf, sizeof(const packcr_capture_t *) * m);
        table->max = m;
    }
    for (i = table->len; i < len; i++) table->buf[i] = NULL;
    table->len = len;
}

static void packcr_capture_const_table__term(packcr_auxil_t auxil, packcr_capture_const_table_t *table) {
    PACKCR_FREE(auxil, (void *)table->buf);
}

MARK_FUNC_AS_USED
static packcr_thunk_t *packcr_thunk__create_leaf(packcr_auxil_t auxil, packcr_action_t action, size_t valuec, size_t captc) {
    packcr_thunk_t *const thunk = (packcr_thunk_t *)PACKCR_MALLOC(auxil, sizeof(packcr_thunk_t));
    thunk->type = PACKCR_THUNK_LEAF;
    packcr_value_refer_table__init(auxil, &thunk->data.leaf.values);
    packcr_value_refer_table__resize(auxil, &thunk->data.leaf.values, valuec);
    packcr_capture_const_table__init(auxil, &thunk->data.leaf.capts);
    packcr_capture_const_table__resize(auxil, &thunk->data.leaf.capts, captc);
    thunk->data.leaf.capt0.range.start = 0;
    thunk->data.leaf.capt0.range.end = 0;
    packcr_location_init(&thunk->data.leaf.capt0.range.start_loc);
    packcr_location_init(&thunk->data.leaf.capt0.range.end_loc);
    thunk->data.leaf.capt0.string = NULL;
    thunk->data.leaf.action = action;
    return thunk;
}

static packcr_thunk_t *packcr_thunk__create_node(packcr_auxil_t auxil, const packcr_thunk_array_t *thunks, packcr_value_t *value) {
    packcr_thunk_t *const thunk = (packcr_thunk_t *)PACKCR_MALLOC(auxil, sizeof(packcr_thunk_t));
    thunk->type = PACKCR_THUNK_NODE;
    thunk->data.node.thunks = thunks;
    thunk->data.node.value = value;
    return thunk;
}

static void packcr_thunk__destroy(packcr_auxil_t auxil, packcr_thunk_t *thunk) {
    if (thunk == NULL) return;
    switch (thunk->type) {
    case PACKCR_THUNK_LEAF:
        PACKCR_FREE(auxil, thunk->data.leaf.capt0.string);
        packcr_capture_const_table__term(auxil, &thunk->data.leaf.capts);
        packcr_value_refer_table__term(auxil, &thunk->data.leaf.values);
        break;
    case PACKCR_THUNK_NODE:
        break;
    default: /* unknown */
        break;
    }
    PACKCR_FREE(auxil, thunk);
}

static void packcr_thunk_array__init(packcr_auxil_t auxil, packcr_thunk_array_t *array) {
    array->len = 0;
    array->max = 0;
    array->buf = NULL;
}

static void packcr_thunk_array__add(packcr_auxil_t auxil, packcr_thunk_array_t *array, packcr_thunk_t *thunk) {
    if (array->max <= array->len) {
        const size_t n = array->len + 1;
        size_t m = array->max;
        if (m == 0) m = PACKCR_ARRAY_MIN_SIZE;
        while (m < n && m != 0) m <<= 1;
        if (m == 0) m = n;
        array->buf = (packcr_thunk_t **)PACKCR_REALLOC(auxil, array->buf, sizeof(packcr_thunk_t *) * m);
        array->max = m;
    }
    array->buf[array->len++] = thunk;
}

static void packcr_thunk_array__revert(packcr_auxil_t auxil, packcr_thunk_array_t *array, size_t len) {
    while (array->len > len) {
        array->len--;
        packcr_thunk__destroy(auxil, array->buf[array->len]);
    }
}

static void packcr_thunk_array__term(packcr_auxil_t auxil, packcr_thunk_array_t *array) {
    while (array->len > 0) {
        array->len--;
        packcr_thunk__destroy(auxil, array->buf[array->len]);
    }
    PACKCR_FREE(auxil, array->buf);
}

static void packcr_memory_recycler__init(packcr_auxil_t auxil, packcr_memory_recycler_t *recycler, size_t element_size) {
    recycler->pool_list = NULL;
    recycler->entry_list = NULL;
    recycler->element_size = element_size;
}

static void *packcr_memory_recycler__supply(packcr_auxil_t auxil, packcr_memory_recycler_t *recycler) {
    if (recycler->entry_list) {
        packcr_memory_entry_t *const tmp = recycler->entry_list;
        recycler->entry_list = tmp->next;
        return tmp;
    }
    if (!recycler->pool_list || recycler->pool_list->unused == 0) {
        size_t size = PACKCR_POOL_MIN_SIZE;
        if (recycler->pool_list) {
            size = recycler->pool_list->allocated << 1;
            if (size == 0) size = recycler->pool_list->allocated;
        }
        {
            packcr_memory_pool_t *const pool = (packcr_memory_pool_t *)PACKCR_MALLOC(
                auxil, sizeof(packcr_memory_pool_t) + recycler->element_size * size
            );
            pool->allocated = size;
            pool->unused = size;
            pool->next = recycler->pool_list;
            recycler->pool_list = pool;
        }
    }
    recycler->pool_list->unused--;
    return (char *)recycler->pool_list + sizeof(packcr_memory_pool_t) + recycler->element_size * recycler->pool_list->unused;
}

static void packcr_memory_recycler__recycle(packcr_auxil_t auxil, packcr_memory_recycler_t *recycler, void *ptr) {
    packcr_memory_entry_t *const tmp = (packcr_memory_entry_t *)ptr;
    tmp->next = recycler->entry_list;
    recycler->entry_list = tmp;
}

static void packcr_memory_recycler__term(packcr_auxil_t auxil, packcr_memory_recycler_t *recycler) {
    while (recycler->pool_list) {
        packcr_memory_pool_t *const tmp = recycler->pool_list;
        recycler->pool_list = tmp->next;
        PACKCR_FREE(auxil, tmp);
    }
}

MARK_FUNC_AS_USED
static packcr_thunk_chunk_t *packcr_thunk_chunk__create(packcr_context_t *ctx) {
    packcr_thunk_chunk_t *const chunk = (packcr_thunk_chunk_t *)packcr_memory_recycler__supply(ctx->auxil, &ctx->thunk_chunk_recycler);
    packcr_value_table__init(ctx->auxil, &chunk->values);
    packcr_capture_table__init(ctx->auxil, &chunk->capts);
    packcr_thunk_array__init(ctx->auxil, &chunk->thunks);
    chunk->pos = 0;
    return chunk;
}

static void packcr_thunk_chunk__destroy(packcr_context_t *ctx, packcr_thunk_chunk_t *chunk) {
    if (chunk == NULL) return;
    packcr_thunk_array__term(ctx->auxil, &chunk->thunks);
    packcr_capture_table__term(ctx->auxil, &chunk->capts);
    packcr_value_table__term(ctx->auxil, &chunk->values);
    packcr_memory_recycler__recycle(ctx->auxil, &ctx->thunk_chunk_recycler, chunk);
}

static void packcr_rule_set__init(packcr_auxil_t auxil, packcr_rule_set_t *set) {
    set->len = 0;
    set->max = 0;
    set->buf = NULL;
}

static size_t packcr_rule_set__index(packcr_auxil_t auxil, const packcr_rule_set_t *set, packcr_rule_t rule) {
    size_t i;
    for (i = 0; i < set->len; i++) {
        if (set->buf[i] == rule) return i;
    }
    return PACKCR_VOID_VALUE;
}

static packcr_bool_t packcr_rule_set__add(packcr_auxil_t auxil, packcr_rule_set_t *set, packcr_rule_t rule) {
    const size_t i = packcr_rule_set__index(auxil, set, rule);
    if (i != PACKCR_VOID_VALUE) return PACKCR_FALSE;
    if (set->max <= set->len) {
        const size_t n = set->len + 1;
        size_t m = set->max;
        if (m == 0) m = PACKCR_ARRAY_MIN_SIZE;
        while (m < n && m != 0) m <<= 1;
        if (m == 0) m = n;
        set->buf = (packcr_rule_t *)PACKCR_REALLOC(auxil, set->buf, sizeof(packcr_rule_t) * m);
        set->max = m;
    }
    set->buf[set->len++] = rule;
    return PACKCR_TRUE;
}

static void packcr_rule_set__term(packcr_auxil_t auxil, packcr_rule_set_t *set) {
    PACKCR_FREE(auxil, set->buf);
}

static packcr_lr_memo_t *packcr_lr_memo__create(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc) {
    packcr_lr_memo_t *memo = (packcr_lr_memo_t *)packcr_memory_recycler__supply(ctx->auxil, &ctx->lr_memo_recycler);
    memo->offset = offset;
    memo->offset_loc = offset_loc;
    memo->chunk = NULL;
    memo->fail = PACKCR_TRUE;
    memo->grow = PACKCR_FALSE;
    memo->hold = NULL;
    return memo;
}

static void packcr_lr_memo__set_chunk(packcr_context_t *ctx, packcr_lr_memo_t *memo, packcr_thunk_chunk_t *chunk) {
    if (memo->chunk) {
        packcr_lr_memo_t *const new_hold_memo = packcr_lr_memo__create(ctx, memo->offset, memo->offset_loc);
        new_hold_memo->chunk = memo->chunk;
        new_hold_memo->hold = memo->hold;
        memo->hold = new_hold_memo;
    }
    memo->chunk = chunk;
    memo->fail = PACKCR_FALSE;
}

static void packcr_lr_memo__destroy(packcr_context_t *ctx, packcr_lr_memo_t *memo) {
    while (memo != NULL) {
        packcr_lr_memo_t *const hold_memo = memo->hold;
        packcr_thunk_chunk__destroy(ctx, memo->chunk);
        packcr_memory_recycler__recycle(ctx->auxil, &ctx->lr_memo_recycler, memo);
        memo = hold_memo;
    }
}

static void packcr_lr_memo_map__init(packcr_auxil_t auxil, packcr_lr_memo_map_t *map) {
    map->len = 0;
    map->max = 0;
    map->buf = NULL;
}

static size_t packcr_lr_memo_map__index(packcr_context_t *ctx, packcr_lr_memo_map_t *map, packcr_rule_t rule) {
    size_t i;
    for (i = 0; i < map->len; i++) {
        if (map->buf[i].rule == rule) return i;
    }
    return PACKCR_VOID_VALUE;
}

static void packcr_lr_memo_map__put(packcr_context_t *ctx, packcr_lr_memo_map_t *map, packcr_rule_t rule, packcr_lr_memo_t *memo) {
    const size_t i = packcr_lr_memo_map__index(ctx, map, rule);
    if (i != PACKCR_VOID_VALUE) {
        packcr_lr_memo__destroy(ctx, map->buf[i].memo);
        map->buf[i].memo = memo;
    }
    else {
        if (map->max <= map->len) {
            const size_t n = map->len + 1;
            size_t m = map->max;
            if (m == 0) m = PACKCR_ARRAY_MIN_SIZE;
            while (m < n && m != 0) m <<= 1;
            if (m == 0) m = n;
            map->buf = (packcr_lr_memo_map_entry_t *)PACKCR_REALLOC(ctx->auxil, map->buf, sizeof(packcr_lr_memo_map_entry_t) * m);
            map->max = m;
        }
        map->buf[map->len].rule = rule;
        map->buf[map->len].memo = memo;
        map->len++;
    }
}

static packcr_lr_memo_t *packcr_lr_memo_map__get(packcr_context_t *ctx, packcr_lr_memo_map_t *map, packcr_rule_t rule) {
    const size_t i = packcr_lr_memo_map__index(ctx, map, rule);
    return (i != PACKCR_VOID_VALUE) ? map->buf[i].memo : NULL;
}

static void packcr_lr_memo_map__term(packcr_context_t *ctx, packcr_lr_memo_map_t *map) {
    while (map->len > 0) {
        map->len--;
        packcr_lr_memo__destroy(ctx, map->buf[map->len].memo);
    }
    PACKCR_FREE(ctx->auxil, map->buf);
}

static packcr_lr_memo_map_t *packcr_lr_memo_map__create(packcr_context_t *ctx) {
    packcr_lr_memo_map_t *const memo = (packcr_lr_memo_map_t *)PACKCR_MALLOC(ctx->auxil, sizeof(packcr_lr_memo_map_t));
    packcr_lr_memo_map__init(ctx->auxil, memo);
    return memo;
}

static void packcr_lr_memo_map__destroy(packcr_context_t *ctx, packcr_lr_memo_map_t *memo) {
    if (memo == NULL) return;
    packcr_lr_memo_map__term(ctx, memo);
    PACKCR_FREE(ctx->auxil, memo);
}

static void packcr_lr_table__init(packcr_auxil_t auxil, packcr_lr_table_t *table) {
    table->ofs = 0;
    table->len = 0;
    table->max = 0;
    table->buf = NULL;
}

static void packcr_lr_table__resize(packcr_context_t *ctx, packcr_lr_table_t *table, size_t len) {
    size_t i;
    for (i = len; i < table->len; i++) packcr_lr_memo_map__destroy(ctx, table->buf[i]);
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = PACKCR_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (packcr_lr_memo_map_t **)PACKCR_REALLOC(ctx->auxil, table->buf, sizeof(packcr_lr_memo_map_t *) * m);
        table->max = m;
    }
    for (i = table->len; i < len; i++) table->buf[i] = NULL;
    table->len = len;
}

static void packcr_lr_table__set_memo(packcr_context_t *ctx, packcr_lr_table_t *table, size_t index, packcr_rule_t rule, packcr_lr_memo_t *memo) {
    index += table->ofs;
    if (index >= table->len) packcr_lr_table__resize(ctx, table, index + 1);
    if (table->buf[index] == NULL) table->buf[index] = packcr_lr_memo_map__create(ctx);
    packcr_lr_memo_map__put(ctx, table->buf[index], rule, memo);
}

static packcr_lr_memo_t *packcr_lr_table__get_memo(packcr_context_t *ctx, packcr_lr_table_t *table, size_t index, packcr_rule_t rule) {
    index += table->ofs;
    if (index >= table->len || table->buf[index] == NULL) return NULL;
    return packcr_lr_memo_map__get(ctx, table->buf[index], rule);
}

static void packcr_lr_table__shift(packcr_context_t *ctx, packcr_lr_table_t *table, size_t count) {
    size_t i;
    if (count > table->len - table->ofs) count = table->len - table->ofs;
    for (i = 0; i < count; i++) packcr_lr_memo_map__destroy(ctx, table->buf[table->ofs++]);
    if (table->ofs > (table->max >> 1)) {
        memmove(table->buf, table->buf + table->ofs, sizeof(packcr_lr_memo_map_t *) * (table->len - table->ofs));
        table->len -= table->ofs;
        table->ofs = 0;
    }
}

static void packcr_lr_table__term(packcr_context_t *ctx, packcr_lr_table_t *table) {
    while (table->len > table->ofs) {
        table->len--;
        packcr_lr_memo_map__destroy(ctx, table->buf[table->len]);
    }
    PACKCR_FREE(ctx->auxil, table->buf);
}

static packcr_context_t *packcr_context__create(packcr_auxil_t auxil) {
    packcr_context_t *const ctx = (packcr_context_t *)PACKCR_MALLOC(auxil, sizeof(packcr_context_t));
    ctx->buffer_start_position = 0;
    ctx->position_offset = 0;
    packcr_location_init(&ctx->buffer_start_position_loc);
    packcr_location_init(&ctx->position_offset_loc);
    ctx->level = 0;
    packcr_char_array__init(auxil, &ctx->buffer);
    packcr_lr_table__init(auxil, &ctx->lrtable);
    packcr_thunk_array__init(auxil, &ctx->thunks);
    packcr_memory_recycler__init(auxil, &ctx->thunk_chunk_recycler, sizeof(packcr_thunk_chunk_t));
    packcr_memory_recycler__init(auxil, &ctx->lr_memo_recycler, sizeof(packcr_lr_memo_t));
    ctx->auxil = auxil;
    return ctx;
}

static void packcr_context__destroy(packcr_context_t *ctx) {
    if (ctx == NULL) return;
    packcr_thunk_array__term(ctx->auxil, &ctx->thunks);
    packcr_lr_table__term(ctx, &ctx->lrtable);
    packcr_char_array__term(ctx->auxil, &ctx->buffer);
    packcr_memory_recycler__term(ctx->auxil, &ctx->thunk_chunk_recycler);
    packcr_memory_recycler__term(ctx->auxil, &ctx->lr_memo_recycler);
    PACKCR_FREE(ctx->auxil, ctx);
}

static size_t packcr_refill_buffer(packcr_context_t *ctx, size_t num) {
    if (ctx->buffer.len >= ctx->position_offset + num) return ctx->buffer.len - ctx->position_offset;
    while (ctx->buffer.len < ctx->position_offset + num) {
        const int c = PACKCR_GETCHAR(ctx->auxil);
        if (c < 0) break;
        packcr_char_array__add(ctx->auxil, &ctx->buffer, (char)c);
    }
    return ctx->buffer.len - ctx->position_offset;
}

MARK_FUNC_AS_USED
static void packcr_commit_buffer(packcr_context_t *ctx) {
    memmove(ctx->buffer.buf, ctx->buffer.buf + ctx->position_offset, ctx->buffer.len - ctx->position_offset);
    ctx->buffer.len -= ctx->position_offset;
    ctx->buffer_start_position += ctx->position_offset;
    packcr_lr_table__shift(ctx, &ctx->lrtable, ctx->position_offset);
    ctx->position_offset = 0;
    ctx->buffer_start_position_loc = packcr_location_add(ctx->buffer_start_position_loc, ctx->position_offset_loc);
    packcr_location_init(&ctx->position_offset_loc);
}

MARK_FUNC_AS_USED
static const char *packcr_get_capture_string(packcr_context_t *ctx, const packcr_capture_t *capt) {
    if (capt->string == NULL)
        ((packcr_capture_t *)capt)->string =
            packcr_strndup_e(ctx->auxil, ctx->buffer.buf + capt->range.start, capt->range.end - capt->range.start);
    return capt->string;
}

static size_t packcr_get_char_as_utf32(packcr_context_t *ctx, int *out) { /* with checking UTF-8 validity */
    int c, u;
    size_t n;
    if (packcr_refill_buffer(ctx, 1) < 1) return 0;
    c = (int)(unsigned char)ctx->buffer.buf[ctx->position_offset];
    n = (c < 0x80) ? 1 :
        ((c & 0xe0) == 0xc0) ? 2 :
        ((c & 0xf0) == 0xe0) ? 3 :
        ((c & 0xf8) == 0xf0) ? 4 : 0;
    if (n < 1) return 0;
    if (packcr_refill_buffer(ctx, n) < n) return 0;
    switch (n) {
    case 1:
        u = c;
        break;
    case 2:
        u = c & 0x1f;
        c = (int)(unsigned char)ctx->buffer.buf[ctx->position_offset + 1];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        if (u < 0x80) return 0;
        break;
    case 3:
        u = c & 0x0f;
        c = (int)(unsigned char)ctx->buffer.buf[ctx->position_offset + 1];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        c = (int)(unsigned char)ctx->buffer.buf[ctx->position_offset + 2];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        if (u < 0x800) return 0;
        break;
    case 4:
        u = c & 0x07;
        c = (int)(unsigned char)ctx->buffer.buf[ctx->position_offset + 1];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        c = (int)(unsigned char)ctx->buffer.buf[ctx->position_offset + 2];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        c = (int)(unsigned char)ctx->buffer.buf[ctx->position_offset + 3];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        if (u < 0x10000 || u > 0x10ffff) return 0;
        break;
    default:
        return 0;
    }
    if (out) *out = u;
    return n;
}

static void packcr_grow_lr(packcr_context_t *ctx, packcr_rule_t rule, size_t offset, packcr_location_t offset_loc) {
    while(1) {
        const size_t old_offset = ctx->position_offset;
        packcr_thunk_chunk_t *chunk;
        packcr_lr_memo_t *memo;
        packcr_rule_set_t limits;
        ctx->position_offset = offset;
        ctx->position_offset_loc = offset_loc;
        packcr_rule_set__init(ctx->auxil, &limits);
        packcr_rule_set__add(ctx->auxil, &limits, rule);
        chunk = rule(ctx, offset, offset_loc, &limits);
        packcr_rule_set__term(ctx->auxil, &limits);
        if (!chunk)
            break;
        if (ctx->position_offset <= old_offset) {
            packcr_thunk_chunk__destroy(ctx, chunk);
            break;
        }
        memo = packcr_lr_table__get_memo(ctx, &ctx->lrtable, offset, rule);
        packcr_lr_memo__set_chunk(ctx, memo, chunk);
        memo->offset = ctx->position_offset;
        memo->offset_loc = ctx->position_offset_loc;
    }
}

MARK_FUNC_AS_USED
static packcr_thunk_chunk_t *packcr_get_rule_thunk_chunk(packcr_context_t *ctx, packcr_rule_t rule) {
    packcr_thunk_chunk_t *c = NULL;
    size_t offset = ctx->position_offset;
    packcr_location_t offset_loc = ctx->position_offset_loc;
    packcr_lr_memo_t *memo = packcr_lr_table__get_memo(ctx, &ctx->lrtable, offset, rule);

    if (memo == NULL) {
        memo = packcr_lr_memo__create(ctx, offset, offset_loc);
        packcr_lr_table__set_memo(ctx, &ctx->lrtable, offset, rule, memo);
        c = rule(ctx, offset, offset_loc, NULL);
        packcr_lr_memo__set_chunk(ctx, memo, c);
        memo->offset = ctx->position_offset;
        memo->offset_loc = ctx->position_offset_loc;
        if (memo->grow) {
            packcr_grow_lr(ctx, rule, offset, offset_loc);
            memo->grow = PACKCR_FALSE;
            ctx->position_offset = memo->offset;
            ctx->position_offset_loc = memo->offset_loc;
            return memo->chunk;
        }
        return c;
    } else if (memo->fail) {
        packcr_lr_memo__set_chunk(ctx, memo, NULL);
        memo->grow = PACKCR_TRUE;
        return NULL;
    }
    ctx->position_offset = memo->offset;
    ctx->position_offset_loc = memo->offset_loc;
    return memo->chunk;
}

MARK_FUNC_AS_USED
static packcr_bool_t packcr_apply_rule(packcr_context_t *ctx, packcr_rule_t rule, packcr_thunk_array_t *thunks, packcr_value_t *value, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    static packcr_value_t null;
    packcr_thunk_chunk_t *c;
    if (limits != NULL) {
        packcr_lr_memo_t *memo;
        packcr_rule_set__add(ctx->auxil, limits, rule);
        c = rule(ctx, offset, offset_loc, limits);
        memo = packcr_lr_table__get_memo(ctx, &ctx->lrtable, offset, rule);
        if (memo == NULL || ctx->position_offset <= memo->offset) {
            if (memo) {
                c = memo->chunk;
                ctx->position_offset = memo->offset;
                ctx->position_offset_loc = memo->offset_loc;
            }
        } else {
            packcr_lr_memo__set_chunk(ctx, memo, c);
            memo->offset = ctx->position_offset;
            memo->offset_loc = ctx->position_offset_loc;
        }
    } else {
        c = packcr_get_rule_thunk_chunk(ctx, rule);
    }
    if (c == NULL) return PACKCR_FALSE;
    if (value == NULL) value = &null;
    memset(value, 0, sizeof(packcr_value_t)); /* in case */
    packcr_thunk_array__add(ctx->auxil, thunks, packcr_thunk__create_node(ctx->auxil, &c->thunks, value));
    return PACKCR_TRUE;
}

MARK_FUNC_AS_USED
static void packcr_do_action(packcr_context_t *ctx, const packcr_thunk_array_t *thunks, packcr_value_t *value) {
    size_t i;
    for (i = 0; i < thunks->len; i++) {
        packcr_thunk_t *const thunk = thunks->buf[i];
        switch (thunk->type) {
        case PACKCR_THUNK_LEAF:
            thunk->data.leaf.action(ctx, thunk, value);
            break;
        case PACKCR_THUNK_NODE:
            packcr_do_action(ctx, thunk->data.node.thunks, thunk->data.node.value);
            break;
        default: /* unknown */
            break;
        }
    }
}

static void packcr_action_dump_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define program (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    tiny_ruby_parser_dump_node(program.node, rb_str_new2("# "));
#undef _0e
#undef _0s
#undef _0
#undef program
#undef __
#undef auxil
}

static void packcr_action_program_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_top_compstmt_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define top_stmts (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
#define _1 packcr_get_capture_string(__packcr_ctx, __packcr_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[0]->range.end))
#define _1sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[0]->range.start_loc)))
#define _1el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[0]->range.end_loc)))
#define _1c (*__packcr_in->data.leaf.capts.buf[0])
    VALUE tbl;
    if (NIL_P(top_stmts.node->var_table)) {
        tbl = rb_ary_new();
    } else {
        tbl = top_stmts.node->var_table;
    }
    __.node = NEW_NODE(NODE_SCOPE, tbl, top_stmts.node, 0, top_stmts.node->nd_loc.beg_pos, top_stmts.node->nd_loc.end_pos);
#undef _1el
#undef _1sl
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef top_stmts
#undef __
#undef auxil
}

static void packcr_action_top_stmts_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define top_stmts (*__packcr_in->data.leaf.values.buf[0])
#define top_stmt (*__packcr_in->data.leaf.values.buf[1])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    top_stmt.node->newline = 1;
    __.node = tiny_ruby_parser_block_append(top_stmts.node, top_stmt.node);
    tiny_ruby_parser_var_table_pass(__.node, top_stmt.node);
#undef _0e
#undef _0s
#undef _0
#undef top_stmt
#undef top_stmts
#undef __
#undef auxil
}

static void packcr_action_top_stmts_1(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define top_stmt (*__packcr_in->data.leaf.values.buf[1])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    top_stmt.node->newline = 1;
    __ = top_stmt;
#undef _0e
#undef _0s
#undef _0
#undef top_stmt
#undef __
#undef auxil
}

static void packcr_action_top_stmts_2(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __.node = NEW_NODE(NODE_BEGIN, 0, 0, 0, _0sl, _0sl);
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void packcr_action_top_stmt_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_stmt_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_compstmt_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_bodystmt_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_stmts_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define stmts (*__packcr_in->data.leaf.values.buf[0])
#define stmt (*__packcr_in->data.leaf.values.buf[1])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    stmt.node->newline = 1;
    __.node = tiny_ruby_parser_block_append(stmts.node, stmt.node);
    tiny_ruby_parser_var_table_pass(__.node, stmt.node);
#undef _0e
#undef _0s
#undef _0
#undef stmt
#undef stmts
#undef __
#undef auxil
}

static void packcr_action_stmts_1(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define stmt (*__packcr_in->data.leaf.values.buf[1])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    stmt.node->newline = 1;
    __.node = stmt.node;
#undef _0e
#undef _0s
#undef _0
#undef stmt
#undef __
#undef auxil
}

static void packcr_action_expr_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_expr_1(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_command_call_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_command_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define fcall (*__packcr_in->data.leaf.values.buf[0])
#define command_args (*__packcr_in->data.leaf.values.buf[1])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    fcall.node->nd_args = command_args.node;
    fcall.node->nd_loc.beg_pos = _0c.range.start_loc;
    fcall.node->nd_loc.end_pos = _0c.range.end_loc;
    __ = fcall;
#undef _0e
#undef _0s
#undef _0
#undef command_args
#undef fcall
#undef __
#undef auxil
}

static void packcr_action_method_call_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define fcall (*__packcr_in->data.leaf.values.buf[0])
#define paren_args (*__packcr_in->data.leaf.values.buf[1])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __.node = fcall.node;
    __.node->nd_args = paren_args.node;
    __.node->nd_loc.end_pos = _0c.range.end_loc;
#undef _0e
#undef _0s
#undef _0
#undef paren_args
#undef fcall
#undef __
#undef auxil
}

static void packcr_action_method_call_1(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define primary (*__packcr_in->data.leaf.values.buf[2])
#define call_op (*__packcr_in->data.leaf.values.buf[3])
#define operation2 (*__packcr_in->data.leaf.values.buf[4])
#define paren_args (*__packcr_in->data.leaf.values.buf[1])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
#define _1 packcr_get_capture_string(__packcr_ctx, __packcr_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[0]->range.end))
#define _1sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[0]->range.start_loc)))
#define _1el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[0]->range.end_loc)))
#define _1c (*__packcr_in->data.leaf.capts.buf[0])
    __.node = paren_args.node;
#undef _1el
#undef _1sl
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef paren_args
#undef operation2
#undef call_op
#undef primary
#undef __
#undef auxil
}

static void packcr_action_method_call_2(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define primary (*__packcr_in->data.leaf.values.buf[2])
#define call_op (*__packcr_in->data.leaf.values.buf[3])
#define operation2 (*__packcr_in->data.leaf.values.buf[4])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
#define _1 packcr_get_capture_string(__packcr_ctx, __packcr_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[0]->range.end))
#define _1sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[0]->range.start_loc)))
#define _1el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[0]->range.end_loc)))
#define _1c (*__packcr_in->data.leaf.capts.buf[0])
    __.node = NULL;
#undef _1el
#undef _1sl
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef operation2
#undef call_op
#undef primary
#undef __
#undef auxil
}

static void packcr_action_method_call_3(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define primary (*__packcr_in->data.leaf.values.buf[2])
#define call_op (*__packcr_in->data.leaf.values.buf[3])
#define operation2 (*__packcr_in->data.leaf.values.buf[4])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
#define _1 packcr_get_capture_string(__packcr_ctx, __packcr_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[0]->range.end))
#define _1sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[0]->range.start_loc)))
#define _1el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[0]->range.end_loc)))
#define _1c (*__packcr_in->data.leaf.capts.buf[0])
    __.node = NEW_NODE(call_op.value, primary.node, operation2.value, __.node, _0sl, _0el);
    __.node->nd_loc.lineno = _1el.lineno;
#undef _1el
#undef _1sl
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef operation2
#undef call_op
#undef primary
#undef __
#undef auxil
}

static void packcr_action_fcall_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define operation (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __.node = NEW_NODE(NODE_FCALL, NULL, operation.node, NULL, _0sl, _0el);
#undef _0e
#undef _0s
#undef _0
#undef operation
#undef __
#undef auxil
}

static void packcr_action_fname_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_fname_1(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_fname_2(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_operation_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_operation2_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_operation2_1(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_op_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __.value = ID2SYM(rb_intern(_0));
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void packcr_action_call_op_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __.value = NODE_CALL;
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void packcr_action_call_op_1(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __.value = NODE_QCALL;
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void packcr_action_command_args_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_paren_args_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_call_args_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_args_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define args (*__packcr_in->data.leaf.values.buf[0])
#define arg_value (*__packcr_in->data.leaf.values.buf[1])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __.node =  tiny_ruby_parser_list_append(args.node, arg_value.node);
#undef _0e
#undef _0s
#undef _0
#undef arg_value
#undef args
#undef __
#undef auxil
}

static void packcr_action_args_1(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define arg_value (*__packcr_in->data.leaf.values.buf[1])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __.node = NEW_NODE(NODE_LIST, arg_value.node, 1, 0, _0sl, _0el);
#undef _0e
#undef _0s
#undef _0
#undef arg_value
#undef __
#undef auxil
}

static void packcr_action_arg_value_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_arg_rhs_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_arg_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_arg_1(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define lhs (*__packcr_in->data.leaf.values.buf[1])
#define arg (*__packcr_in->data.leaf.values.buf[2])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __.node = NEW_NODE(NODE_LASGN, lhs.value, arg.node, 0, _0sl, _0el);
    tiny_ruby_parser_var_table_add(__.node, lhs.value);
#undef _0e
#undef _0s
#undef _0
#undef arg
#undef lhs
#undef __
#undef auxil
}

static void packcr_action_arg_addsub_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define recv (*__packcr_in->data.leaf.values.buf[0])
#define arg (*__packcr_in->data.leaf.values.buf[1])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
#define _1 packcr_get_capture_string(__packcr_ctx, __packcr_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[0]->range.end))
#define _1sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[0]->range.start_loc)))
#define _1el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[0]->range.end_loc)))
#define _1c (*__packcr_in->data.leaf.capts.buf[0])
    NODE *args = NEW_NODE(NODE_LIST, arg.node, 1, 0, arg.node->nd_loc.beg_pos, arg.node->nd_loc.end_pos);
    __.node = NEW_NODE(NODE_OPCALL, recv.node, ID2SYM(rb_intern(_1)), args, _0sl, _0el);
#undef _1el
#undef _1sl
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef arg
#undef recv
#undef __
#undef auxil
}

static void packcr_action_arg_addsub_1(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[2])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_arg_muldiv_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define recv (*__packcr_in->data.leaf.values.buf[0])
#define arg (*__packcr_in->data.leaf.values.buf[1])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
#define _1 packcr_get_capture_string(__packcr_ctx, __packcr_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[0]->range.end))
#define _1sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[0]->range.start_loc)))
#define _1el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[0]->range.end_loc)))
#define _1c (*__packcr_in->data.leaf.capts.buf[0])
    NODE *args = NEW_NODE(NODE_LIST, arg.node, 1, 0, arg.node->nd_loc.beg_pos, arg.node->nd_loc.end_pos);
    __.node = NEW_NODE(NODE_OPCALL, recv.node, ID2SYM(rb_intern(_1)), args, _0sl, _0el);
#undef _1el
#undef _1sl
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef arg
#undef recv
#undef __
#undef auxil
}

static void packcr_action_arg_muldiv_1(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[2])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_arg_primary_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_primary_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define defn_head (*__packcr_in->data.leaf.values.buf[0])
#define f_arglist (*__packcr_in->data.leaf.values.buf[1])
#define bodystmt (*__packcr_in->data.leaf.values.buf[2])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    NODE *body = bodystmt.node;
    if (f_arglist.node->nd_head) {
        body = tiny_ruby_parser_block_append(f_arglist.node->nd_head, bodystmt.node);
        f_arglist.node->nd_head = NULL;
        tiny_ruby_parser_var_table_pass(body, bodystmt.node);
    }
    __.node = tiny_ruby_parser_set_defun_body(defn_head.node, f_arglist.node, body, _0sl, _0el);
    tiny_ruby_parser_var_table_pass(__.node, body);
#undef _0e
#undef _0s
#undef _0
#undef bodystmt
#undef f_arglist
#undef defn_head
#undef __
#undef auxil
}

static void packcr_action_primary_1(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define cpath (*__packcr_in->data.leaf.values.buf[3])
#define bodystmt (*__packcr_in->data.leaf.values.buf[2])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
#define _1 packcr_get_capture_string(__packcr_ctx, __packcr_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[0]->range.end))
#define _1sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[0]->range.start_loc)))
#define _1el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[0]->range.end_loc)))
#define _1c (*__packcr_in->data.leaf.capts.buf[0])
#define _2 packcr_get_capture_string(__packcr_ctx, __packcr_in->data.leaf.capts.buf[1])
#define _2s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[1]->range.start))
#define _2e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[1]->range.end))
#define _2sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[1]->range.start_loc)))
#define _2el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[1]->range.end_loc)))
#define _2c (*__packcr_in->data.leaf.capts.buf[1])
    NODE *body = bodystmt.node;
    if(_2[0] != '\0') {
        body = tiny_ruby_parser_block_append(NEW_NODE(NODE_BEGIN, 0, 0, 0, _1sl, _1sl), bodystmt.node);
        tiny_ruby_parser_var_table_pass(body, bodystmt.node);
    }
    __.node = NEW_NODE(NODE_CLASS, cpath.node, NEW_NODE(NODE_SCOPE, rb_ary_new(), body, 0, _0sl, _0el), NULL, _0sl, _0el);
#undef _2el
#undef _2sl
#undef _2e
#undef _2s
#undef _2
#undef _1el
#undef _1sl
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef bodystmt
#undef cpath
#undef __
#undef auxil
}

static void packcr_action_primary_2(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[4])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_primary_3(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[4])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_primary_4(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[4])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_primary_5(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[4])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_defn_head_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define def_name (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __.node = NEW_NODE(NODE_DEFN, 0, def_name.node->nd_mid, def_name.node, _0sl, _0el);
#undef _0e
#undef _0s
#undef _0
#undef def_name
#undef __
#undef auxil
}

static void packcr_action_def_name_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define fname (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __.node = NEW_NODE(NODE_SELF, 0, fname.node, 0, _0sl, _0el);
#undef _0e
#undef _0s
#undef _0
#undef fname
#undef __
#undef auxil
}

static void packcr_action_f_arglist_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define f_paren_args (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
#define _1 packcr_get_capture_string(__packcr_ctx, __packcr_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[0]->range.end))
#define _1sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[0]->range.start_loc)))
#define _1el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[0]->range.end_loc)))
#define _1c (*__packcr_in->data.leaf.capts.buf[0])
#define _2 packcr_get_capture_string(__packcr_ctx, __packcr_in->data.leaf.capts.buf[1])
#define _2s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[1]->range.start))
#define _2e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[1]->range.end))
#define _2sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[1]->range.start_loc)))
#define _2el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[1]->range.end_loc)))
#define _2c (*__packcr_in->data.leaf.capts.buf[1])
    __ = f_paren_args;
    if(_2[0] != '\0') {
      __.node->nd_head = NEW_NODE(NODE_BEGIN, 0, 0, 0, _1sl, _1sl);
    }
#undef _2el
#undef _2sl
#undef _2e
#undef _2s
#undef _2
#undef _1el
#undef _1sl
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef f_paren_args
#undef __
#undef auxil
}

static void packcr_action_f_arglist_1(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define f_args (*__packcr_in->data.leaf.values.buf[1])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
#define _3 packcr_get_capture_string(__packcr_ctx, __packcr_in->data.leaf.capts.buf[2])
#define _3s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[2]->range.start))
#define _3e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[2]->range.end))
#define _3sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[2]->range.start_loc)))
#define _3el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[2]->range.end_loc)))
#define _3c (*__packcr_in->data.leaf.capts.buf[2])
#define _4 packcr_get_capture_string(__packcr_ctx, __packcr_in->data.leaf.capts.buf[3])
#define _4s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[3]->range.start))
#define _4e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[3]->range.end))
#define _4sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[3]->range.start_loc)))
#define _4el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[3]->range.end_loc)))
#define _4c (*__packcr_in->data.leaf.capts.buf[3])
    __ = f_args;
    if(_4[0] != '\0') {
      __.node->nd_head = NEW_NODE(NODE_BEGIN, 0, 0, 0, _3sl, _3sl);
    }
#undef _4el
#undef _4sl
#undef _4e
#undef _4s
#undef _4
#undef _3el
#undef _3sl
#undef _3e
#undef _3s
#undef _3
#undef _0e
#undef _0s
#undef _0
#undef f_args
#undef __
#undef auxil
}

static void packcr_action_f_paren_args_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_f_args_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define f_arg (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    struct tiny_ruby_parser_args_info *args = calloc(1, sizeof(struct tiny_ruby_parser_args_info));
    args->pre_args_num = RARRAY_LEN(f_arg.node->var_table);
    __.node = NEW_NODE(NODE_ARGS, 0, 0, args, _0sl, _0el);
    tiny_ruby_parser_var_table_pass(__.node, f_arg.node);
#undef _0e
#undef _0s
#undef _0
#undef f_arg
#undef __
#undef auxil
}

static void packcr_action_f_args_1(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    struct tiny_ruby_parser_args_info *args = calloc(1, sizeof(struct tiny_ruby_parser_args_info));
    __.node = NEW_NODE(NODE_ARGS, 0, 0, args, _0sl, _0el);
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void packcr_action_f_arg_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define f_arg (*__packcr_in->data.leaf.values.buf[0])
#define f_arg_item (*__packcr_in->data.leaf.values.buf[1])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __.node = f_arg.node;
    __.node->nd_plen++;
    __.node->nd_next = tiny_ruby_parser_block_append(__.node->nd_next, f_arg_item.node->nd_next);
    tiny_ruby_parser_var_table_pass(__.node, f_arg_item.node);
    free(f_arg_item.node);
#undef _0e
#undef _0s
#undef _0
#undef f_arg_item
#undef f_arg
#undef __
#undef auxil
}

static void packcr_action_f_arg_1(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[2])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_f_arg_item_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define f_arg_asgn (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __.node = NEW_NODE(NODE_ARGS_AUX, f_arg_asgn.value, 1, 0, NULL_LOC.beg_pos, NULL_LOC.end_pos);
    tiny_ruby_parser_var_table_add(__.node, f_arg_asgn.value);
#undef _0e
#undef _0s
#undef _0
#undef f_arg_asgn
#undef __
#undef auxil
}

static void packcr_action_f_arg_asgn_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_f_norm_arg_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_cpath_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define cname (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __.node = NEW_NODE(NODE_COLON2, 0, cname.value, 0, _0sl, _0el);
#undef _0e
#undef _0s
#undef _0
#undef cname
#undef __
#undef auxil
}

static void packcr_action_literal_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_strings_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_string_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_string1_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define string_content (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __.node = NEW_NODE(NODE_STR, string_content.value, 0, 0, _0sl, _0el);
#undef _0e
#undef _0s
#undef _0
#undef string_content
#undef __
#undef auxil
}

static void packcr_action_string1_1(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define string_content (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
#define _1 packcr_get_capture_string(__packcr_ctx, __packcr_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[0]->range.end))
#define _1sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[0]->range.start_loc)))
#define _1el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[0]->range.end_loc)))
#define _1c (*__packcr_in->data.leaf.capts.buf[0])
    VALUE str = string_content.value;
    if(_1[0] != '\0') {
        str = rb_str_concat(str, rb_str_new2("#"));
    }
    __.node = NEW_NODE(NODE_STR, str, 0, 0, _0sl, _0el);
#undef _1el
#undef _1sl
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef string_content
#undef __
#undef auxil
}

static void packcr_action_sq_str_content_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define sq_str_content (*__packcr_in->data.leaf.values.buf[0])
#define sq_str_chunk (*__packcr_in->data.leaf.values.buf[1])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __.value = rb_str_concat(sq_str_content.value, sq_str_chunk.value);
#undef _0e
#undef _0s
#undef _0
#undef sq_str_chunk
#undef sq_str_content
#undef __
#undef auxil
}

static void packcr_action_sq_str_content_1(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[2])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_sq_str_content_2(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __.value = rb_str_new2("");
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void packcr_action_sq_str_chunk_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
#define _1 packcr_get_capture_string(__packcr_ctx, __packcr_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[0]->range.end))
#define _1sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[0]->range.start_loc)))
#define _1el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[0]->range.end_loc)))
#define _1c (*__packcr_in->data.leaf.capts.buf[0])
    __.value = rb_str_new2(_1);
#undef _1el
#undef _1sl
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void packcr_action_sq_str_chunk_1(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
#define _2 packcr_get_capture_string(__packcr_ctx, __packcr_in->data.leaf.capts.buf[1])
#define _2s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[1]->range.start))
#define _2e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[1]->range.end))
#define _2sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[1]->range.start_loc)))
#define _2el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[1]->range.end_loc)))
#define _2c (*__packcr_in->data.leaf.capts.buf[1])
    __.value = rb_str_new(_2 + 1, 1);
#undef _2el
#undef _2sl
#undef _2e
#undef _2s
#undef _2
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void packcr_action_dq_str_content_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define dq_str_content (*__packcr_in->data.leaf.values.buf[0])
#define dq_str_chunk (*__packcr_in->data.leaf.values.buf[1])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __.value = rb_str_concat(dq_str_content.value, dq_str_chunk.value);
#undef _0e
#undef _0s
#undef _0
#undef dq_str_chunk
#undef dq_str_content
#undef __
#undef auxil
}

static void packcr_action_dq_str_content_1(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[2])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_dq_str_content_2(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __.value = rb_str_new2("");
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void packcr_action_dq_str_chunk_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
#define _1 packcr_get_capture_string(__packcr_ctx, __packcr_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[0]->range.end))
#define _1sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[0]->range.start_loc)))
#define _1el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[0]->range.end_loc)))
#define _1c (*__packcr_in->data.leaf.capts.buf[0])
    __.value = rb_str_new2(_1);
#undef _1el
#undef _1sl
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void packcr_action_dq_str_chunk_1(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
#define _2 packcr_get_capture_string(__packcr_ctx, __packcr_in->data.leaf.capts.buf[1])
#define _2s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[1]->range.start))
#define _2e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[1]->range.end))
#define _2sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[1]->range.start_loc)))
#define _2el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[1]->range.end_loc)))
#define _2c (*__packcr_in->data.leaf.capts.buf[1])
    __.value = rb_str_new(_2 + 1, 1);
#undef _2el
#undef _2sl
#undef _2e
#undef _2s
#undef _2
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void packcr_action_numeric_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_simple_numeric_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _out (*__packcr_in->data.leaf.values.buf[0])
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __ = _out;
#undef _0e
#undef _0s
#undef _0
#undef _out
#undef __
#undef auxil
}

static void packcr_action_tINTEGER_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
#define _1 packcr_get_capture_string(__packcr_ctx, __packcr_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[0]->range.end))
#define _1sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[0]->range.start_loc)))
#define _1el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[0]->range.end_loc)))
#define _1c (*__packcr_in->data.leaf.capts.buf[0])
    __.node = NEW_NODE(NODE_LIT, tiny_ruby_parser_cstr2num(_1, 16), 0, 0, _0sl, _0el);
#undef _1el
#undef _1sl
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void packcr_action_tINTEGER_1(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
#define _2 packcr_get_capture_string(__packcr_ctx, __packcr_in->data.leaf.capts.buf[1])
#define _2s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[1]->range.start))
#define _2e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[1]->range.end))
#define _2sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[1]->range.start_loc)))
#define _2el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[1]->range.end_loc)))
#define _2c (*__packcr_in->data.leaf.capts.buf[1])
    __.node = NEW_NODE(NODE_LIT, tiny_ruby_parser_cstr2num(_2, 8), 0, 0, _0sl, _0el);
#undef _2el
#undef _2sl
#undef _2e
#undef _2s
#undef _2
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void packcr_action_tINTEGER_2(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
#define _3 packcr_get_capture_string(__packcr_ctx, __packcr_in->data.leaf.capts.buf[2])
#define _3s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[2]->range.start))
#define _3e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[2]->range.end))
#define _3sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[2]->range.start_loc)))
#define _3el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[2]->range.end_loc)))
#define _3c (*__packcr_in->data.leaf.capts.buf[2])
    __.node = NEW_NODE(NODE_LIT, tiny_ruby_parser_cstr2num(_3, 2), 0, 0, _0sl, _0el);
#undef _3el
#undef _3sl
#undef _3e
#undef _3s
#undef _3
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void packcr_action_tINTEGER_3(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
#define _4 packcr_get_capture_string(__packcr_ctx, __packcr_in->data.leaf.capts.buf[3])
#define _4s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[3]->range.start))
#define _4e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[3]->range.end))
#define _4sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[3]->range.start_loc)))
#define _4el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[3]->range.end_loc)))
#define _4c (*__packcr_in->data.leaf.capts.buf[3])
    __.node = NEW_NODE(NODE_LIT, tiny_ruby_parser_cstr2num(_4, 10), 0, 0, _0sl, _0el);
#undef _4el
#undef _4sl
#undef _4e
#undef _4s
#undef _4
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void packcr_action_tIDENTIFIER_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __.value = ID2SYM(rb_intern(_0));
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void packcr_action_tCONSTANT_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __.value = ID2SYM(rb_intern(_0));
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void packcr_action_term_0(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __.value = LONG2NUM(';');
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void packcr_action_term_1(tiny_ruby_parser_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
#define _0c __packcr_in->data.leaf.capt0
    __.value = LONG2NUM('\n');
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_dump(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_program(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_top_compstmt(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_top_stmts(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_top_stmt(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_stmt(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_compstmt(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_bodystmt(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_stmts(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_expr(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_command_call(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_command(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_method_call(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_fcall(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_fname(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_operation(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_operation2(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_op(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_call_op(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_tANDDOT(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_command_args(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_paren_args(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_call_args(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_args(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_arg_value(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_arg_rhs(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_arg(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_arg_addsub(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_arg_muldiv(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_arg_primary(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_primary(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_defn_head(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_def_name(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_f_arglist(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_f_paren_args(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_f_args(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_f_arg(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_f_arg_item(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_f_arg_asgn(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_f_norm_arg(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_cpath(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_literal(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_strings(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_string(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_string1(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_sq_str_content(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_sq_str_chunk(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_dq_str_content(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_dq_str_chunk(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_numeric(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_simple_numeric(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_tINTEGER(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_tIDENTIFIER(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_tCONSTANT(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_term(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_spaces(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);
static packcr_thunk_chunk_t *packcr_evaluate_rule_EOF(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits);

static packcr_thunk_chunk_t *packcr_evaluate_rule_dump(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "dump", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_program) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_program, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_dump_0, 1, 0);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "dump", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "dump", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_program(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "program", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_top_compstmt) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_top_compstmt, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_program_0, 1, 0);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    {
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            if (
                packcr_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.buf[ctx->position_offset] != '\n'
            ) goto L0001;
                packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
            ctx->position_offset++;
            if (ctx->position_offset == p) break;
            continue;
        L0001:;
            ctx->position_offset = p;
            ctx->position_offset_loc = p_loc;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_EOF) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_EOF, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0000;
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "program", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "program", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_top_compstmt(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "top_compstmt", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        const size_t p = ctx->position_offset;
        size_t q;
        packcr_location_t p_loc = ctx->position_offset_loc;
        packcr_location_t q_loc;
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_top_stmts) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_top_stmts, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
        }
        q = ctx->position_offset;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        q_loc = ctx->position_offset_loc;
        chunk->capts.buf[0].range.start_loc = p_loc;
        chunk->capts.buf[0].range.end_loc = q_loc;
    }
    {
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                packcr_rule_set_t *l = NULL;
                if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_term) == PACKCR_VOID_VALUE) {
                    l = limits;
                }
                if (!packcr_apply_rule(ctx, packcr_evaluate_rule_term, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0001;
            }
            if (ctx->position_offset == p) break;
            continue;
        L0001:;
            ctx->position_offset = p;
            ctx->position_offset_loc = p_loc;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_top_compstmt_0, 1, 1);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "top_compstmt", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "top_compstmt", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_top_stmts(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "top_stmts", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 2);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        const size_t p = ctx->position_offset;
        const packcr_location_t p_loc = ctx->position_offset_loc;
        const size_t n = chunk->thunks.len;
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_top_stmts) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_top_stmts, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0002;
        }
        {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                packcr_rule_set_t *l = NULL;
                if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                    l = limits;
                }
                if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0003;
            }
            goto L0004;
        L0003:;
            ctx->position_offset_loc = p_loc;
            ctx->position_offset = p;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0004:;
        }
        {
            const size_t p0 = ctx->position_offset;
            const packcr_location_t p0_loc = ctx->position_offset_loc;
            const size_t n0 = chunk->thunks.len;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->position_offset;
                const packcr_location_t p_loc = ctx->position_offset_loc;
                const size_t n = chunk->thunks.len;
                {
                    packcr_rule_set_t *l = NULL;
                    if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_term) == PACKCR_VOID_VALUE) {
                        l = limits;
                    }
                    if (!packcr_apply_rule(ctx, packcr_evaluate_rule_term, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0005;
                }
                if (ctx->position_offset == p) break;
                continue;
            L0005:;
                ctx->position_offset = p;
                ctx->position_offset_loc = p_loc;
                packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
            if (i < 1) {
                ctx->position_offset = p0;
                ctx->position_offset_loc = p0_loc;
                packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                goto L0002;
            }
        }
        {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                packcr_rule_set_t *l = NULL;
                if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                    l = limits;
                }
                if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0006;
            }
            goto L0007;
        L0006:;
            ctx->position_offset_loc = p_loc;
            ctx->position_offset = p;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0007:;
        }
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_top_stmt) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_top_stmt, &chunk->thunks, &(chunk->values.buf[1]), offset, offset_loc, l)) goto L0002;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_top_stmts_0, 2, 0);
            thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
            thunk->data.leaf.values.buf[1] = &(chunk->values.buf[1]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_top_stmt) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_top_stmt, &chunk->thunks, &(chunk->values.buf[1]), offset, offset_loc, l)) goto L0008;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_top_stmts_1, 2, 0);
            thunk->data.leaf.values.buf[1] = &(chunk->values.buf[1]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0008:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                packcr_rule_set_t *l = NULL;
                if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                    l = limits;
                }
                if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0010;
            }
            goto L0011;
        L0010:;
            ctx->position_offset_loc = p_loc;
            ctx->position_offset = p;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0011:;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_top_stmts_2, 2, 0);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
    L0001:;
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "top_stmts", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_top_stmt(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "top_stmt", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_stmt) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_stmt, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_top_stmt_0, 1, 0);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "top_stmt", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "top_stmt", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_stmt(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "stmt", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_expr) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_expr, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_stmt_0, 1, 0);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "stmt", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "stmt", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_compstmt(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "compstmt", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_stmts) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_stmts, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_compstmt_0, 1, 0);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    {
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                packcr_rule_set_t *l = NULL;
                if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_term) == PACKCR_VOID_VALUE) {
                    l = limits;
                }
                if (!packcr_apply_rule(ctx, packcr_evaluate_rule_term, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0001;
            }
            if (ctx->position_offset == p) break;
            continue;
        L0001:;
            ctx->position_offset = p;
            ctx->position_offset_loc = p_loc;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "compstmt", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "compstmt", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_bodystmt(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "bodystmt", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_compstmt) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_compstmt, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_bodystmt_0, 1, 0);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "bodystmt", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "bodystmt", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_stmts(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "stmts", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 2);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        const size_t p = ctx->position_offset;
        const packcr_location_t p_loc = ctx->position_offset_loc;
        const size_t n = chunk->thunks.len;
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_stmts) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_stmts, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0002;
        }
        {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                packcr_rule_set_t *l = NULL;
                if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                    l = limits;
                }
                if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0003;
            }
            goto L0004;
        L0003:;
            ctx->position_offset_loc = p_loc;
            ctx->position_offset = p;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0004:;
        }
        {
            const size_t p0 = ctx->position_offset;
            const packcr_location_t p0_loc = ctx->position_offset_loc;
            const size_t n0 = chunk->thunks.len;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->position_offset;
                const packcr_location_t p_loc = ctx->position_offset_loc;
                const size_t n = chunk->thunks.len;
                {
                    packcr_rule_set_t *l = NULL;
                    if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_term) == PACKCR_VOID_VALUE) {
                        l = limits;
                    }
                    if (!packcr_apply_rule(ctx, packcr_evaluate_rule_term, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0005;
                }
                if (ctx->position_offset == p) break;
                continue;
            L0005:;
                ctx->position_offset = p;
                ctx->position_offset_loc = p_loc;
                packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
            if (i < 1) {
                ctx->position_offset = p0;
                ctx->position_offset_loc = p0_loc;
                packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                goto L0002;
            }
        }
        {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                packcr_rule_set_t *l = NULL;
                if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                    l = limits;
                }
                if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0006;
            }
            goto L0007;
        L0006:;
            ctx->position_offset_loc = p_loc;
            ctx->position_offset = p;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0007:;
        }
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_stmt) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_stmt, &chunk->thunks, &(chunk->values.buf[1]), offset, offset_loc, l)) goto L0002;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_stmts_0, 2, 0);
            thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
            thunk->data.leaf.values.buf[1] = &(chunk->values.buf[1]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_stmt) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_stmt, &chunk->thunks, &(chunk->values.buf[1]), offset, offset_loc, l)) goto L0008;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_stmts_1, 2, 0);
            thunk->data.leaf.values.buf[1] = &(chunk->values.buf[1]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0008:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "stmts", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "stmts", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_expr(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "expr", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        const size_t p = ctx->position_offset;
        const packcr_location_t p_loc = ctx->position_offset_loc;
        const size_t n = chunk->thunks.len;
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_command_call) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_command_call, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0002;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_expr_0, 1, 0);
            thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_arg) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_arg, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0003;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_expr_1, 1, 0);
            thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0003:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "expr", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "expr", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_command_call(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "command_call", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_command) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_command, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_command_call_0, 1, 0);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "command_call", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "command_call", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_command(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "command", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 2);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_fcall) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_fcall, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_command_args) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_command_args, &chunk->thunks, &(chunk->values.buf[1]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_command_0, 2, 0);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.values.buf[1] = &(chunk->values.buf[1]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "command", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "command", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_method_call(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "method_call", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 5);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        const size_t p = ctx->position_offset;
        const packcr_location_t p_loc = ctx->position_offset_loc;
        const size_t n = chunk->thunks.len;
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_fcall) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_fcall, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0002;
        }
        {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                packcr_rule_set_t *l = NULL;
                if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                    l = limits;
                }
                if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0003;
            }
            goto L0004;
        L0003:;
            ctx->position_offset_loc = p_loc;
            ctx->position_offset = p;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0004:;
        }
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_paren_args) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_paren_args, &chunk->thunks, &(chunk->values.buf[1]), offset, offset_loc, l)) goto L0002;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_method_call_0, 5, 1);
            thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
            thunk->data.leaf.values.buf[1] = &(chunk->values.buf[1]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_primary) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_primary, &chunk->thunks, &(chunk->values.buf[2]), offset, offset_loc, l)) goto L0005;
        }
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_call_op) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_call_op, &chunk->thunks, &(chunk->values.buf[3]), offset, offset_loc, l)) goto L0005;
        }
        {
            const size_t p = ctx->position_offset;
            size_t q;
            packcr_location_t p_loc = ctx->position_offset_loc;
            packcr_location_t q_loc;
            {
                packcr_rule_set_t *l = NULL;
                if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_operation2) == PACKCR_VOID_VALUE) {
                    l = limits;
                }
                if (!packcr_apply_rule(ctx, packcr_evaluate_rule_operation2, &chunk->thunks, &(chunk->values.buf[4]), offset, offset_loc, l)) goto L0005;
            }
            q = ctx->position_offset;
            chunk->capts.buf[0].range.start = p;
            chunk->capts.buf[0].range.end = q;
            q_loc = ctx->position_offset_loc;
            chunk->capts.buf[0].range.start_loc = p_loc;
            chunk->capts.buf[0].range.end_loc = q_loc;
        }
        {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                packcr_rule_set_t *l = NULL;
                if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_paren_args) == PACKCR_VOID_VALUE) {
                    l = limits;
                }
                if (!packcr_apply_rule(ctx, packcr_evaluate_rule_paren_args, &chunk->thunks, &(chunk->values.buf[1]), offset, offset_loc, l)) goto L0007;
            }
            {
                packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_method_call_1, 5, 1);
                thunk->data.leaf.values.buf[2] = &(chunk->values.buf[2]);
                thunk->data.leaf.values.buf[3] = &(chunk->values.buf[3]);
                thunk->data.leaf.values.buf[4] = &(chunk->values.buf[4]);
                thunk->data.leaf.values.buf[1] = &(chunk->values.buf[1]);
                thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
                thunk->data.leaf.capt0.range.start = chunk->pos;
                thunk->data.leaf.capt0.range.end = ctx->position_offset;
                thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
                thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
                packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
            }
            goto L0006;
        L0007:;
            ctx->position_offset = p;
            ctx->position_offset_loc = p_loc;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            {
                packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_method_call_2, 5, 1);
                thunk->data.leaf.values.buf[2] = &(chunk->values.buf[2]);
                thunk->data.leaf.values.buf[3] = &(chunk->values.buf[3]);
                thunk->data.leaf.values.buf[4] = &(chunk->values.buf[4]);
                thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
                thunk->data.leaf.capt0.range.start = chunk->pos;
                thunk->data.leaf.capt0.range.end = ctx->position_offset;
                thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
                thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
                packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
            }
        L0006:;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_method_call_3, 5, 1);
            thunk->data.leaf.values.buf[2] = &(chunk->values.buf[2]);
            thunk->data.leaf.values.buf[3] = &(chunk->values.buf[3]);
            thunk->data.leaf.values.buf[4] = &(chunk->values.buf[4]);
            thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0005:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "method_call", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "method_call", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_fcall(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "fcall", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_operation) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_operation, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_fcall_0, 1, 0);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "fcall", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "fcall", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_fname(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "fname", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        const size_t p = ctx->position_offset;
        const packcr_location_t p_loc = ctx->position_offset_loc;
        const size_t n = chunk->thunks.len;
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_tIDENTIFIER) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_tIDENTIFIER, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0002;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_fname_0, 1, 0);
            thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_tCONSTANT) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_tCONSTANT, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0003;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_fname_1, 1, 0);
            thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0003:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_op) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_op, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0004;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_fname_2, 1, 0);
            thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0004:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "fname", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "fname", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_operation(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "operation", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_tIDENTIFIER) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_tIDENTIFIER, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_operation_0, 1, 0);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "operation", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "operation", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_operation2(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "operation2", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        const size_t p = ctx->position_offset;
        const packcr_location_t p_loc = ctx->position_offset_loc;
        const size_t n = chunk->thunks.len;
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_operation) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_operation, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0002;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_operation2_0, 1, 0);
            thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_op) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_op, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0003;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_operation2_1, 1, 0);
            thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0003:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "operation2", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "operation2", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_op(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "op", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 0);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        int u;
        const size_t n = packcr_get_char_as_utf32(ctx, &u);
        if (n == 0) goto L0000;
        if (!(
            u == 0x00002d ||
            u == 0x00002b ||
            u == 0x00002f ||
            u == 0x000025 ||
            u == 0x00002a
        )) goto L0000;
        packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, n);
        ctx->position_offset += n;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_op_0, 0, 0);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "op", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "op", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_call_op(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "call_op", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 0);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const size_t p = ctx->position_offset;
        const packcr_location_t p_loc = ctx->position_offset_loc;
        const size_t n = chunk->thunks.len;
        if (
            packcr_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->position_offset] != '.'
        ) goto L0002;
            packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
        ctx->position_offset++;
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_call_op_0, 0, 0);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_tANDDOT) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_tANDDOT, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0003;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_call_op_1, 0, 0);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0003:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "call_op", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "call_op", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_tANDDOT(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "tANDDOT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 0);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (
        packcr_refill_buffer(ctx, 2) < 2 ||
        (ctx->buffer.buf + ctx->position_offset)[0] != '&' ||
        (ctx->buffer.buf + ctx->position_offset)[1] != '.'
    ) goto L0000;
    packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 2);
    ctx->position_offset += 2;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "tANDDOT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "tANDDOT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_command_args(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "command_args", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_call_args) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_call_args, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_command_args_0, 1, 0);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "command_args", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "command_args", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_paren_args(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "paren_args", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    if (
        packcr_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->position_offset] != '('
    ) goto L0000;
        packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
    ctx->position_offset++;
    {
        const size_t p = ctx->position_offset;
        const packcr_location_t p_loc = ctx->position_offset_loc;
        const size_t n = chunk->thunks.len;
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0001;
        }
        goto L0002;
    L0001:;
        ctx->position_offset_loc = p_loc;
        ctx->position_offset = p;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    {
        const size_t p = ctx->position_offset;
        const packcr_location_t p_loc = ctx->position_offset_loc;
        const size_t n = chunk->thunks.len;
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_call_args) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_call_args, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0003;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_paren_args_0, 1, 0);
            thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0004;
    L0003:;
        ctx->position_offset_loc = p_loc;
        ctx->position_offset = p;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0004:;
    }
    {
        const size_t p = ctx->position_offset;
        const packcr_location_t p_loc = ctx->position_offset_loc;
        const size_t n = chunk->thunks.len;
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0005;
        }
        goto L0006;
    L0005:;
        ctx->position_offset_loc = p_loc;
        ctx->position_offset = p;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0006:;
    }
    if (
        packcr_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->position_offset] != ')'
    ) goto L0000;
        packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
    ctx->position_offset++;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "paren_args", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "paren_args", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_call_args(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "call_args", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_args) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_args, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_call_args_0, 1, 0);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "call_args", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "call_args", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_args(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "args", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 2);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        const size_t p = ctx->position_offset;
        const packcr_location_t p_loc = ctx->position_offset_loc;
        const size_t n = chunk->thunks.len;
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_args) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_args, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0002;
        }
        {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                packcr_rule_set_t *l = NULL;
                if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                    l = limits;
                }
                if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0003;
            }
            goto L0004;
        L0003:;
            ctx->position_offset_loc = p_loc;
            ctx->position_offset = p;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0004:;
        }
        if (
            packcr_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->position_offset] != ','
        ) goto L0002;
            packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
        ctx->position_offset++;
        {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                packcr_rule_set_t *l = NULL;
                if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                    l = limits;
                }
                if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0005;
            }
            goto L0006;
        L0005:;
            ctx->position_offset_loc = p_loc;
            ctx->position_offset = p;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0006:;
        }
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_arg_value) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_arg_value, &chunk->thunks, &(chunk->values.buf[1]), offset, offset_loc, l)) goto L0002;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_args_0, 2, 0);
            thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
            thunk->data.leaf.values.buf[1] = &(chunk->values.buf[1]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_arg_value) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_arg_value, &chunk->thunks, &(chunk->values.buf[1]), offset, offset_loc, l)) goto L0007;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_args_1, 2, 0);
            thunk->data.leaf.values.buf[1] = &(chunk->values.buf[1]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0007:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "args", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "args", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_arg_value(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "arg_value", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_arg) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_arg, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_arg_value_0, 1, 0);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "arg_value", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "arg_value", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_arg_rhs(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "arg_rhs", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_arg) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_arg, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_arg_rhs_0, 1, 0);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "arg_rhs", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "arg_rhs", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_arg(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "arg", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 3);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        const size_t p = ctx->position_offset;
        const packcr_location_t p_loc = ctx->position_offset_loc;
        const size_t n = chunk->thunks.len;
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_arg_addsub) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_arg_addsub, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0002;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_arg_0, 3, 0);
            thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_tIDENTIFIER) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_tIDENTIFIER, &chunk->thunks, &(chunk->values.buf[1]), offset, offset_loc, l)) goto L0003;
        }
        {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                packcr_rule_set_t *l = NULL;
                if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                    l = limits;
                }
                if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0004;
            }
            goto L0005;
        L0004:;
            ctx->position_offset_loc = p_loc;
            ctx->position_offset = p;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0005:;
        }
        if (
            packcr_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->position_offset] != '='
        ) goto L0003;
            packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
        ctx->position_offset++;
        {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                packcr_rule_set_t *l = NULL;
                if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                    l = limits;
                }
                if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0006;
            }
            goto L0007;
        L0006:;
            ctx->position_offset_loc = p_loc;
            ctx->position_offset = p;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0007:;
        }
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_arg_rhs) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_arg_rhs, &chunk->thunks, &(chunk->values.buf[2]), offset, offset_loc, l)) goto L0003;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_arg_1, 3, 0);
            thunk->data.leaf.values.buf[1] = &(chunk->values.buf[1]);
            thunk->data.leaf.values.buf[2] = &(chunk->values.buf[2]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0003:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "arg", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "arg", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_arg_addsub(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "arg_addsub", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 3);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        const size_t p = ctx->position_offset;
        const packcr_location_t p_loc = ctx->position_offset_loc;
        const size_t n = chunk->thunks.len;
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_arg_addsub) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_arg_addsub, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0002;
        }
        {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                packcr_rule_set_t *l = NULL;
                if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                    l = limits;
                }
                if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0003;
            }
            goto L0004;
        L0003:;
            ctx->position_offset_loc = p_loc;
            ctx->position_offset = p;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0004:;
        }
        {
            const size_t p = ctx->position_offset;
            size_t q;
            packcr_location_t p_loc = ctx->position_offset_loc;
            packcr_location_t q_loc;
            {
                int u;
                const size_t n = packcr_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0002;
                if (!(
                    u == 0x00002d ||
                    u == 0x00002b
                )) goto L0002;
                packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, n);
                ctx->position_offset += n;
            }
            q = ctx->position_offset;
            chunk->capts.buf[0].range.start = p;
            chunk->capts.buf[0].range.end = q;
            q_loc = ctx->position_offset_loc;
            chunk->capts.buf[0].range.start_loc = p_loc;
            chunk->capts.buf[0].range.end_loc = q_loc;
        }
        {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                packcr_rule_set_t *l = NULL;
                if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                    l = limits;
                }
                if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0005;
            }
            goto L0006;
        L0005:;
            ctx->position_offset_loc = p_loc;
            ctx->position_offset = p;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0006:;
        }
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_arg_muldiv) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_arg_muldiv, &chunk->thunks, &(chunk->values.buf[1]), offset, offset_loc, l)) goto L0002;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_arg_addsub_0, 3, 1);
            thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
            thunk->data.leaf.values.buf[1] = &(chunk->values.buf[1]);
            thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_arg_muldiv) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_arg_muldiv, &chunk->thunks, &(chunk->values.buf[2]), offset, offset_loc, l)) goto L0007;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_arg_addsub_1, 3, 1);
            thunk->data.leaf.values.buf[2] = &(chunk->values.buf[2]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0007:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "arg_addsub", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "arg_addsub", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_arg_muldiv(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "arg_muldiv", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 3);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        const size_t p = ctx->position_offset;
        const packcr_location_t p_loc = ctx->position_offset_loc;
        const size_t n = chunk->thunks.len;
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_arg_muldiv) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_arg_muldiv, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0002;
        }
        {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                packcr_rule_set_t *l = NULL;
                if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                    l = limits;
                }
                if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0003;
            }
            goto L0004;
        L0003:;
            ctx->position_offset_loc = p_loc;
            ctx->position_offset = p;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0004:;
        }
        {
            const size_t p = ctx->position_offset;
            size_t q;
            packcr_location_t p_loc = ctx->position_offset_loc;
            packcr_location_t q_loc;
            {
                int u;
                const size_t n = packcr_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0002;
                if (!(
                    u == 0x00002a ||
                    u == 0x00002f ||
                    u == 0x000025
                )) goto L0002;
                packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, n);
                ctx->position_offset += n;
            }
            q = ctx->position_offset;
            chunk->capts.buf[0].range.start = p;
            chunk->capts.buf[0].range.end = q;
            q_loc = ctx->position_offset_loc;
            chunk->capts.buf[0].range.start_loc = p_loc;
            chunk->capts.buf[0].range.end_loc = q_loc;
        }
        {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                packcr_rule_set_t *l = NULL;
                if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                    l = limits;
                }
                if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0005;
            }
            goto L0006;
        L0005:;
            ctx->position_offset_loc = p_loc;
            ctx->position_offset = p;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0006:;
        }
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_arg_primary) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_arg_primary, &chunk->thunks, &(chunk->values.buf[1]), offset, offset_loc, l)) goto L0002;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_arg_muldiv_0, 3, 1);
            thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
            thunk->data.leaf.values.buf[1] = &(chunk->values.buf[1]);
            thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_arg_primary) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_arg_primary, &chunk->thunks, &(chunk->values.buf[2]), offset, offset_loc, l)) goto L0007;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_arg_muldiv_1, 3, 1);
            thunk->data.leaf.values.buf[2] = &(chunk->values.buf[2]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0007:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "arg_muldiv", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "arg_muldiv", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_arg_primary(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "arg_primary", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_primary) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_primary, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_arg_primary_0, 1, 0);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "arg_primary", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "arg_primary", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_primary(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "primary", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 5);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 2);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        const size_t p = ctx->position_offset;
        const packcr_location_t p_loc = ctx->position_offset_loc;
        const size_t n = chunk->thunks.len;
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_defn_head) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_defn_head, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0002;
        }
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_f_arglist) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_f_arglist, &chunk->thunks, &(chunk->values.buf[1]), offset, offset_loc, l)) goto L0002;
        }
        {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                packcr_rule_set_t *l = NULL;
                if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                    l = limits;
                }
                if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0003;
            }
            goto L0004;
        L0003:;
            ctx->position_offset_loc = p_loc;
            ctx->position_offset = p;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0004:;
        }
        {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                packcr_rule_set_t *l = NULL;
                if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_bodystmt) == PACKCR_VOID_VALUE) {
                    l = limits;
                }
                if (!packcr_apply_rule(ctx, packcr_evaluate_rule_bodystmt, &chunk->thunks, &(chunk->values.buf[2]), offset, offset_loc, l)) goto L0005;
            }
            goto L0006;
        L0005:;
            ctx->position_offset_loc = p_loc;
            ctx->position_offset = p;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0006:;
        }
        {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                packcr_rule_set_t *l = NULL;
                if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                    l = limits;
                }
                if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0007;
            }
            goto L0008;
        L0007:;
            ctx->position_offset_loc = p_loc;
            ctx->position_offset = p;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0008:;
        }
        if (
            packcr_refill_buffer(ctx, 3) < 3 ||
            (ctx->buffer.buf + ctx->position_offset)[0] != 'e' ||
            (ctx->buffer.buf + ctx->position_offset)[1] != 'n' ||
            (ctx->buffer.buf + ctx->position_offset)[2] != 'd'
        ) goto L0002;
        packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 3);
        ctx->position_offset += 3;
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_primary_0, 5, 2);
            thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
            thunk->data.leaf.values.buf[1] = &(chunk->values.buf[1]);
            thunk->data.leaf.values.buf[2] = &(chunk->values.buf[2]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            packcr_refill_buffer(ctx, 5) < 5 ||
            (ctx->buffer.buf + ctx->position_offset)[0] != 'c' ||
            (ctx->buffer.buf + ctx->position_offset)[1] != 'l' ||
            (ctx->buffer.buf + ctx->position_offset)[2] != 'a' ||
            (ctx->buffer.buf + ctx->position_offset)[3] != 's' ||
            (ctx->buffer.buf + ctx->position_offset)[4] != 's'
        ) goto L0009;
        packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 5);
        ctx->position_offset += 5;
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0009;
        }
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_cpath) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_cpath, &chunk->thunks, &(chunk->values.buf[3]), offset, offset_loc, l)) goto L0009;
        }
        {
            const size_t p = ctx->position_offset;
            size_t q;
            packcr_location_t p_loc = ctx->position_offset_loc;
            packcr_location_t q_loc;
            {
                const size_t p = ctx->position_offset;
                const packcr_location_t p_loc = ctx->position_offset_loc;
                const size_t n = chunk->thunks.len;
                {
                    packcr_rule_set_t *l = NULL;
                    if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                        l = limits;
                    }
                    if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0010;
                }
                goto L0011;
            L0010:;
                ctx->position_offset_loc = p_loc;
                ctx->position_offset = p;
                packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            L0011:;
            }
            q = ctx->position_offset;
            chunk->capts.buf[0].range.start = p;
            chunk->capts.buf[0].range.end = q;
            q_loc = ctx->position_offset_loc;
            chunk->capts.buf[0].range.start_loc = p_loc;
            chunk->capts.buf[0].range.end_loc = q_loc;
        }
        {
            const size_t p = ctx->position_offset;
            size_t q;
            packcr_location_t p_loc = ctx->position_offset_loc;
            packcr_location_t q_loc;
            {
                const size_t p = ctx->position_offset;
                const packcr_location_t p_loc = ctx->position_offset_loc;
                const size_t n = chunk->thunks.len;
                {
                    packcr_rule_set_t *l = NULL;
                    if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_term) == PACKCR_VOID_VALUE) {
                        l = limits;
                    }
                    if (!packcr_apply_rule(ctx, packcr_evaluate_rule_term, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0012;
                }
                goto L0013;
            L0012:;
                ctx->position_offset_loc = p_loc;
                ctx->position_offset = p;
                packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            L0013:;
            }
            q = ctx->position_offset;
            chunk->capts.buf[1].range.start = p;
            chunk->capts.buf[1].range.end = q;
            q_loc = ctx->position_offset_loc;
            chunk->capts.buf[1].range.start_loc = p_loc;
            chunk->capts.buf[1].range.end_loc = q_loc;
        }
        {
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->position_offset;
                {
                    const size_t p = ctx->position_offset;
                    const packcr_location_t p_loc = ctx->position_offset_loc;
                    const size_t n = chunk->thunks.len;
                    {
                        packcr_rule_set_t *l = NULL;
                        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                            l = limits;
                        }
                        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0015;
                    }
                    goto L0016;
                L0015:;
                    ctx->position_offset_loc = p_loc;
                    ctx->position_offset = p;
                    packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                L0016:;
                }
                {
                    const size_t p = ctx->position_offset;
                    const packcr_location_t p_loc = ctx->position_offset_loc;
                    const size_t n = chunk->thunks.len;
                    {
                        packcr_rule_set_t *l = NULL;
                        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_term) == PACKCR_VOID_VALUE) {
                            l = limits;
                        }
                        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_term, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0017;
                    }
                    goto L0018;
                L0017:;
                    ctx->position_offset_loc = p_loc;
                    ctx->position_offset = p;
                    packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                L0018:;
                }
                if (ctx->position_offset == p) break;
            }
        }
        {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                packcr_rule_set_t *l = NULL;
                if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_bodystmt) == PACKCR_VOID_VALUE) {
                    l = limits;
                }
                if (!packcr_apply_rule(ctx, packcr_evaluate_rule_bodystmt, &chunk->thunks, &(chunk->values.buf[2]), offset, offset_loc, l)) goto L0019;
            }
            goto L0020;
        L0019:;
            ctx->position_offset_loc = p_loc;
            ctx->position_offset = p;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0020:;
        }
        {
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->position_offset;
                {
                    const size_t p = ctx->position_offset;
                    const packcr_location_t p_loc = ctx->position_offset_loc;
                    const size_t n = chunk->thunks.len;
                    {
                        packcr_rule_set_t *l = NULL;
                        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                            l = limits;
                        }
                        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0022;
                    }
                    goto L0023;
                L0022:;
                    ctx->position_offset_loc = p_loc;
                    ctx->position_offset = p;
                    packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                L0023:;
                }
                {
                    const size_t p = ctx->position_offset;
                    const packcr_location_t p_loc = ctx->position_offset_loc;
                    const size_t n = chunk->thunks.len;
                    {
                        packcr_rule_set_t *l = NULL;
                        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_term) == PACKCR_VOID_VALUE) {
                            l = limits;
                        }
                        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_term, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0024;
                    }
                    goto L0025;
                L0024:;
                    ctx->position_offset_loc = p_loc;
                    ctx->position_offset = p;
                    packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                L0025:;
                }
                if (ctx->position_offset == p) break;
            }
        }
        if (
            packcr_refill_buffer(ctx, 3) < 3 ||
            (ctx->buffer.buf + ctx->position_offset)[0] != 'e' ||
            (ctx->buffer.buf + ctx->position_offset)[1] != 'n' ||
            (ctx->buffer.buf + ctx->position_offset)[2] != 'd'
        ) goto L0009;
        packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 3);
        ctx->position_offset += 3;
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_primary_1, 5, 2);
            thunk->data.leaf.values.buf[3] = &(chunk->values.buf[3]);
            thunk->data.leaf.values.buf[2] = &(chunk->values.buf[2]);
            thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
            thunk->data.leaf.capts.buf[1] = &(chunk->capts.buf[1]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0009:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_method_call) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_method_call, &chunk->thunks, &(chunk->values.buf[4]), offset, offset_loc, l)) goto L0026;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_primary_2, 5, 2);
            thunk->data.leaf.values.buf[4] = &(chunk->values.buf[4]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0026:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_literal) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_literal, &chunk->thunks, &(chunk->values.buf[4]), offset, offset_loc, l)) goto L0027;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_primary_3, 5, 2);
            thunk->data.leaf.values.buf[4] = &(chunk->values.buf[4]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0027:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_strings) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_strings, &chunk->thunks, &(chunk->values.buf[4]), offset, offset_loc, l)) goto L0028;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_primary_4, 5, 2);
            thunk->data.leaf.values.buf[4] = &(chunk->values.buf[4]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0028:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            packcr_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->position_offset] != '('
        ) goto L0029;
            packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
        ctx->position_offset++;
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_compstmt) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_compstmt, &chunk->thunks, &(chunk->values.buf[4]), offset, offset_loc, l)) goto L0029;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_primary_5, 5, 2);
            thunk->data.leaf.values.buf[4] = &(chunk->values.buf[4]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        if (
            packcr_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->position_offset] != ')'
        ) goto L0029;
            packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
        ctx->position_offset++;
        goto L0001;
    L0029:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "primary", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "primary", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_defn_head(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "defn_head", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    if (
        packcr_refill_buffer(ctx, 3) < 3 ||
        (ctx->buffer.buf + ctx->position_offset)[0] != 'd' ||
        (ctx->buffer.buf + ctx->position_offset)[1] != 'e' ||
        (ctx->buffer.buf + ctx->position_offset)[2] != 'f'
    ) goto L0000;
    packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 3);
    ctx->position_offset += 3;
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_def_name) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_def_name, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_defn_head_0, 1, 0);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "defn_head", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "defn_head", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_def_name(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "def_name", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_fname) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_fname, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_def_name_0, 1, 0);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "def_name", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "def_name", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_f_arglist(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "f_arglist", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 2);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 4);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        const size_t p = ctx->position_offset;
        const packcr_location_t p_loc = ctx->position_offset_loc;
        const size_t n = chunk->thunks.len;
        {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                packcr_rule_set_t *l = NULL;
                if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                    l = limits;
                }
                if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0003;
            }
            goto L0004;
        L0003:;
            ctx->position_offset_loc = p_loc;
            ctx->position_offset = p;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0004:;
        }
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_f_paren_args) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_f_paren_args, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0002;
        }
        {
            const size_t p = ctx->position_offset;
            size_t q;
            packcr_location_t p_loc = ctx->position_offset_loc;
            packcr_location_t q_loc;
            {
                const size_t p = ctx->position_offset;
                const packcr_location_t p_loc = ctx->position_offset_loc;
                const size_t n = chunk->thunks.len;
                {
                    packcr_rule_set_t *l = NULL;
                    if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                        l = limits;
                    }
                    if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0005;
                }
                goto L0006;
            L0005:;
                ctx->position_offset_loc = p_loc;
                ctx->position_offset = p;
                packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            L0006:;
            }
            q = ctx->position_offset;
            chunk->capts.buf[0].range.start = p;
            chunk->capts.buf[0].range.end = q;
            q_loc = ctx->position_offset_loc;
            chunk->capts.buf[0].range.start_loc = p_loc;
            chunk->capts.buf[0].range.end_loc = q_loc;
        }
        {
            const size_t p = ctx->position_offset;
            size_t q;
            packcr_location_t p_loc = ctx->position_offset_loc;
            packcr_location_t q_loc;
            {
                const size_t p = ctx->position_offset;
                const packcr_location_t p_loc = ctx->position_offset_loc;
                const size_t n = chunk->thunks.len;
                {
                    packcr_rule_set_t *l = NULL;
                    if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_term) == PACKCR_VOID_VALUE) {
                        l = limits;
                    }
                    if (!packcr_apply_rule(ctx, packcr_evaluate_rule_term, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0007;
                }
                goto L0008;
            L0007:;
                ctx->position_offset_loc = p_loc;
                ctx->position_offset = p;
                packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            L0008:;
            }
            q = ctx->position_offset;
            chunk->capts.buf[1].range.start = p;
            chunk->capts.buf[1].range.end = q;
            q_loc = ctx->position_offset_loc;
            chunk->capts.buf[1].range.start_loc = p_loc;
            chunk->capts.buf[1].range.end_loc = q_loc;
        }
        {
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->position_offset;
                const packcr_location_t p_loc = ctx->position_offset_loc;
                const size_t n = chunk->thunks.len;
                {
                    int i;
                    for (i = 0;; i++) {
                        const size_t p = ctx->position_offset;
                        const packcr_location_t p_loc = ctx->position_offset_loc;
                        const size_t n = chunk->thunks.len;
                        {
                            packcr_rule_set_t *l = NULL;
                            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                                l = limits;
                            }
                            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0010;
                        }
                        if (ctx->position_offset == p) break;
                        continue;
                    L0010:;
                        ctx->position_offset = p;
                        ctx->position_offset_loc = p_loc;
                        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        break;
                    }
                }
                {
                    packcr_rule_set_t *l = NULL;
                    if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_term) == PACKCR_VOID_VALUE) {
                        l = limits;
                    }
                    if (!packcr_apply_rule(ctx, packcr_evaluate_rule_term, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0009;
                }
                if (ctx->position_offset == p) break;
                continue;
            L0009:;
                ctx->position_offset = p;
                ctx->position_offset_loc = p_loc;
                packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_f_arglist_0, 2, 4);
            thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
            thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
            thunk->data.leaf.capts.buf[1] = &(chunk->capts.buf[1]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_f_args) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_f_args, &chunk->thunks, &(chunk->values.buf[1]), offset, offset_loc, l)) goto L0011;
        }
        {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                packcr_rule_set_t *l = NULL;
                if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                    l = limits;
                }
                if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0012;
            }
            goto L0013;
        L0012:;
            ctx->position_offset_loc = p_loc;
            ctx->position_offset = p;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0013:;
        }
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_term) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_term, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0011;
        }
        {
            const size_t p = ctx->position_offset;
            size_t q;
            packcr_location_t p_loc = ctx->position_offset_loc;
            packcr_location_t q_loc;
            {
                const size_t p = ctx->position_offset;
                const packcr_location_t p_loc = ctx->position_offset_loc;
                const size_t n = chunk->thunks.len;
                {
                    packcr_rule_set_t *l = NULL;
                    if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                        l = limits;
                    }
                    if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0014;
                }
                goto L0015;
            L0014:;
                ctx->position_offset_loc = p_loc;
                ctx->position_offset = p;
                packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            L0015:;
            }
            q = ctx->position_offset;
            chunk->capts.buf[2].range.start = p;
            chunk->capts.buf[2].range.end = q;
            q_loc = ctx->position_offset_loc;
            chunk->capts.buf[2].range.start_loc = p_loc;
            chunk->capts.buf[2].range.end_loc = q_loc;
        }
        {
            const size_t p = ctx->position_offset;
            size_t q;
            packcr_location_t p_loc = ctx->position_offset_loc;
            packcr_location_t q_loc;
            {
                const size_t p = ctx->position_offset;
                const packcr_location_t p_loc = ctx->position_offset_loc;
                const size_t n = chunk->thunks.len;
                {
                    packcr_rule_set_t *l = NULL;
                    if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_term) == PACKCR_VOID_VALUE) {
                        l = limits;
                    }
                    if (!packcr_apply_rule(ctx, packcr_evaluate_rule_term, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0016;
                }
                goto L0017;
            L0016:;
                ctx->position_offset_loc = p_loc;
                ctx->position_offset = p;
                packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            L0017:;
            }
            q = ctx->position_offset;
            chunk->capts.buf[3].range.start = p;
            chunk->capts.buf[3].range.end = q;
            q_loc = ctx->position_offset_loc;
            chunk->capts.buf[3].range.start_loc = p_loc;
            chunk->capts.buf[3].range.end_loc = q_loc;
        }
        {
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->position_offset;
                const packcr_location_t p_loc = ctx->position_offset_loc;
                const size_t n = chunk->thunks.len;
                {
                    int i;
                    for (i = 0;; i++) {
                        const size_t p = ctx->position_offset;
                        const packcr_location_t p_loc = ctx->position_offset_loc;
                        const size_t n = chunk->thunks.len;
                        {
                            packcr_rule_set_t *l = NULL;
                            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                                l = limits;
                            }
                            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0019;
                        }
                        if (ctx->position_offset == p) break;
                        continue;
                    L0019:;
                        ctx->position_offset = p;
                        ctx->position_offset_loc = p_loc;
                        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        break;
                    }
                }
                {
                    packcr_rule_set_t *l = NULL;
                    if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_term) == PACKCR_VOID_VALUE) {
                        l = limits;
                    }
                    if (!packcr_apply_rule(ctx, packcr_evaluate_rule_term, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0018;
                }
                if (ctx->position_offset == p) break;
                continue;
            L0018:;
                ctx->position_offset = p;
                ctx->position_offset_loc = p_loc;
                packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_f_arglist_1, 2, 4);
            thunk->data.leaf.values.buf[1] = &(chunk->values.buf[1]);
            thunk->data.leaf.capts.buf[2] = &(chunk->capts.buf[2]);
            thunk->data.leaf.capts.buf[3] = &(chunk->capts.buf[3]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0011:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "f_arglist", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "f_arglist", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_f_paren_args(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "f_paren_args", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    if (
        packcr_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->position_offset] != '('
    ) goto L0000;
        packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
    ctx->position_offset++;
    {
        const size_t p = ctx->position_offset;
        const packcr_location_t p_loc = ctx->position_offset_loc;
        const size_t n = chunk->thunks.len;
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0001;
        }
        goto L0002;
    L0001:;
        ctx->position_offset_loc = p_loc;
        ctx->position_offset = p;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_f_args) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_f_args, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_f_paren_args_0, 1, 0);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    {
        const size_t p = ctx->position_offset;
        const packcr_location_t p_loc = ctx->position_offset_loc;
        const size_t n = chunk->thunks.len;
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0003;
        }
        goto L0004;
    L0003:;
        ctx->position_offset_loc = p_loc;
        ctx->position_offset = p;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0004:;
    }
    if (
        packcr_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->position_offset] != ')'
    ) goto L0000;
        packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
    ctx->position_offset++;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "f_paren_args", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "f_paren_args", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_f_args(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "f_args", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        const size_t p = ctx->position_offset;
        const packcr_location_t p_loc = ctx->position_offset_loc;
        const size_t n = chunk->thunks.len;
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_f_arg) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_f_arg, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0002;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_f_args_0, 1, 0);
            thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_f_args_1, 1, 0);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
    L0001:;
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "f_args", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_f_arg(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "f_arg", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 3);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        const size_t p = ctx->position_offset;
        const packcr_location_t p_loc = ctx->position_offset_loc;
        const size_t n = chunk->thunks.len;
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_f_arg) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_f_arg, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0002;
        }
        {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                packcr_rule_set_t *l = NULL;
                if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                    l = limits;
                }
                if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0003;
            }
            goto L0004;
        L0003:;
            ctx->position_offset_loc = p_loc;
            ctx->position_offset = p;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0004:;
        }
        if (
            packcr_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->position_offset] != ','
        ) goto L0002;
            packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
        ctx->position_offset++;
        {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                packcr_rule_set_t *l = NULL;
                if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_spaces) == PACKCR_VOID_VALUE) {
                    l = limits;
                }
                if (!packcr_apply_rule(ctx, packcr_evaluate_rule_spaces, &chunk->thunks, NULL, offset, offset_loc, l)) goto L0005;
            }
            goto L0006;
        L0005:;
            ctx->position_offset_loc = p_loc;
            ctx->position_offset = p;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0006:;
        }
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_f_arg_item) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_f_arg_item, &chunk->thunks, &(chunk->values.buf[1]), offset, offset_loc, l)) goto L0002;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_f_arg_0, 3, 0);
            thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
            thunk->data.leaf.values.buf[1] = &(chunk->values.buf[1]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_f_arg_item) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_f_arg_item, &chunk->thunks, &(chunk->values.buf[2]), offset, offset_loc, l)) goto L0007;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_f_arg_1, 3, 0);
            thunk->data.leaf.values.buf[2] = &(chunk->values.buf[2]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0007:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "f_arg", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "f_arg", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_f_arg_item(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "f_arg_item", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_f_arg_asgn) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_f_arg_asgn, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_f_arg_item_0, 1, 0);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "f_arg_item", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "f_arg_item", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_f_arg_asgn(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "f_arg_asgn", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_f_norm_arg) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_f_norm_arg, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_f_arg_asgn_0, 1, 0);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "f_arg_asgn", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "f_arg_asgn", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_f_norm_arg(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "f_norm_arg", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_tIDENTIFIER) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_tIDENTIFIER, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_f_norm_arg_0, 1, 0);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "f_norm_arg", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "f_norm_arg", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_cpath(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "cpath", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_tCONSTANT) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_tCONSTANT, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_cpath_0, 1, 0);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "cpath", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "cpath", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_literal(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "literal", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_numeric) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_numeric, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_literal_0, 1, 0);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "literal", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "literal", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_strings(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "strings", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_string) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_string, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_strings_0, 1, 0);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "strings", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "strings", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_string(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "string", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_string1) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_string1, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_string_0, 1, 0);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "string", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "string", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_string1(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "string1", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        const size_t p = ctx->position_offset;
        const packcr_location_t p_loc = ctx->position_offset_loc;
        const size_t n = chunk->thunks.len;
        if (
            packcr_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->position_offset] != '\''
        ) goto L0002;
            packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
        ctx->position_offset++;
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_sq_str_content) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_sq_str_content, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0002;
        }
        if (
            packcr_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->position_offset] != '\''
        ) goto L0002;
            packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
        ctx->position_offset++;
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_string1_0, 1, 1);
            thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            packcr_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->position_offset] != '\"'
        ) goto L0003;
            packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
        ctx->position_offset++;
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_dq_str_content) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_dq_str_content, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0003;
        }
        {
            const size_t p = ctx->position_offset;
            size_t q;
            packcr_location_t p_loc = ctx->position_offset_loc;
            packcr_location_t q_loc;
            {
                const size_t p = ctx->position_offset;
                const packcr_location_t p_loc = ctx->position_offset_loc;
                const size_t n = chunk->thunks.len;
                if (
                    packcr_refill_buffer(ctx, 1) < 1 ||
                    ctx->buffer.buf[ctx->position_offset] != '#'
                ) goto L0004;
                    packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
                ctx->position_offset++;
                goto L0005;
            L0004:;
                ctx->position_offset_loc = p_loc;
                ctx->position_offset = p;
                packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            L0005:;
            }
            q = ctx->position_offset;
            chunk->capts.buf[0].range.start = p;
            chunk->capts.buf[0].range.end = q;
            q_loc = ctx->position_offset_loc;
            chunk->capts.buf[0].range.start_loc = p_loc;
            chunk->capts.buf[0].range.end_loc = q_loc;
        }
        if (
            packcr_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->position_offset] != '\"'
        ) goto L0003;
            packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
        ctx->position_offset++;
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_string1_1, 1, 1);
            thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
            thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0003:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "string1", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "string1", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_sq_str_content(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "sq_str_content", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 3);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        const size_t p = ctx->position_offset;
        const packcr_location_t p_loc = ctx->position_offset_loc;
        const size_t n = chunk->thunks.len;
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_sq_str_content) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_sq_str_content, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0002;
        }
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_sq_str_chunk) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_sq_str_chunk, &chunk->thunks, &(chunk->values.buf[1]), offset, offset_loc, l)) goto L0002;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_sq_str_content_0, 3, 0);
            thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
            thunk->data.leaf.values.buf[1] = &(chunk->values.buf[1]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_sq_str_chunk) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_sq_str_chunk, &chunk->thunks, &(chunk->values.buf[2]), offset, offset_loc, l)) goto L0003;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_sq_str_content_1, 3, 0);
            thunk->data.leaf.values.buf[2] = &(chunk->values.buf[2]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0003:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_sq_str_content_2, 3, 0);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
    L0001:;
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "sq_str_content", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_sq_str_chunk(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "sq_str_chunk", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 0);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 2);
    {
        const size_t p = ctx->position_offset;
        const packcr_location_t p_loc = ctx->position_offset_loc;
        const size_t n = chunk->thunks.len;
        {
            const size_t p = ctx->position_offset;
            size_t q;
            packcr_location_t p_loc = ctx->position_offset_loc;
            packcr_location_t q_loc;
            {
                const size_t p0 = ctx->position_offset;
                const packcr_location_t p0_loc = ctx->position_offset_loc;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->position_offset;
                    const packcr_location_t p_loc = ctx->position_offset_loc;
                    const size_t n = chunk->thunks.len;
                    {
                        const size_t p = ctx->position_offset;
                        const packcr_location_t p_loc = ctx->position_offset_loc;
                        const size_t n = chunk->thunks.len;
                        {
                            const size_t p0 = ctx->position_offset;
                            const packcr_location_t p0_loc = ctx->position_offset_loc;
                            const size_t n0 = chunk->thunks.len;
                            int i;
                            for (i = 0;; i++) {
                                const size_t p = ctx->position_offset;
                                const packcr_location_t p_loc = ctx->position_offset_loc;
                                const size_t n = chunk->thunks.len;
                                {
                                    int u;
                                    const size_t n = packcr_get_char_as_utf32(ctx, &u);
                                    if (n == 0) goto L0006;
                                    if (
                                        u == 0x00005c ||
                                        u == 0x000027
                                    ) goto L0006;
                                    packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, n);
                                    ctx->position_offset += n;
                                }
                                if (ctx->position_offset == p) break;
                                continue;
                            L0006:;
                                ctx->position_offset = p;
                                ctx->position_offset_loc = p_loc;
                                packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                                break;
                            }
                            if (i < 1) {
                                ctx->position_offset = p0;
                                ctx->position_offset_loc = p0_loc;
                                packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                                goto L0005;
                            }
                        }
                        goto L0004;
                    L0005:;
                        ctx->position_offset = p;
                        ctx->position_offset_loc = p_loc;
                        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        if (
                            packcr_refill_buffer(ctx, 1) < 1 ||
                            ctx->buffer.buf[ctx->position_offset] != '\\'
                        ) goto L0007;
                            packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
                        ctx->position_offset++;
                        {
                            int u;
                            const size_t n = packcr_get_char_as_utf32(ctx, &u);
                            if (n == 0) goto L0007;
                            if (
                                u == 0x00005c ||
                                u == 0x000027
                            ) goto L0007;
                            packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, n);
                            ctx->position_offset += n;
                        }
                        goto L0004;
                    L0007:;
                        ctx->position_offset = p;
                        ctx->position_offset_loc = p_loc;
                        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        goto L0003;
                    L0004:;
                    }
                    if (ctx->position_offset == p) break;
                    continue;
                L0003:;
                    ctx->position_offset = p;
                    ctx->position_offset_loc = p_loc;
                    packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->position_offset = p0;
                    ctx->position_offset_loc = p0_loc;
                    packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                    goto L0002;
                }
            }
            q = ctx->position_offset;
            chunk->capts.buf[0].range.start = p;
            chunk->capts.buf[0].range.end = q;
            q_loc = ctx->position_offset_loc;
            chunk->capts.buf[0].range.start_loc = p_loc;
            chunk->capts.buf[0].range.end_loc = q_loc;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_sq_str_chunk_0, 0, 2);
            thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            const size_t p = ctx->position_offset;
            size_t q;
            packcr_location_t p_loc = ctx->position_offset_loc;
            packcr_location_t q_loc;
            {
                const size_t p = ctx->position_offset;
                const packcr_location_t p_loc = ctx->position_offset_loc;
                const size_t n = chunk->thunks.len;
                if (
                    packcr_refill_buffer(ctx, 2) < 2 ||
                    (ctx->buffer.buf + ctx->position_offset)[0] != '\\' ||
                    (ctx->buffer.buf + ctx->position_offset)[1] != '\\'
                ) goto L0010;
                packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 2);
                ctx->position_offset += 2;
                goto L0009;
            L0010:;
                ctx->position_offset = p;
                ctx->position_offset_loc = p_loc;
                packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                if (
                    packcr_refill_buffer(ctx, 2) < 2 ||
                    (ctx->buffer.buf + ctx->position_offset)[0] != '\\' ||
                    (ctx->buffer.buf + ctx->position_offset)[1] != '\''
                ) goto L0011;
                packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 2);
                ctx->position_offset += 2;
                goto L0009;
            L0011:;
                ctx->position_offset = p;
                ctx->position_offset_loc = p_loc;
                packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                goto L0008;
            L0009:;
            }
            q = ctx->position_offset;
            chunk->capts.buf[1].range.start = p;
            chunk->capts.buf[1].range.end = q;
            q_loc = ctx->position_offset_loc;
            chunk->capts.buf[1].range.start_loc = p_loc;
            chunk->capts.buf[1].range.end_loc = q_loc;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_sq_str_chunk_1, 0, 2);
            thunk->data.leaf.capts.buf[1] = &(chunk->capts.buf[1]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0008:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "sq_str_chunk", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "sq_str_chunk", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_dq_str_content(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "dq_str_content", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 3);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        const size_t p = ctx->position_offset;
        const packcr_location_t p_loc = ctx->position_offset_loc;
        const size_t n = chunk->thunks.len;
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_dq_str_content) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_dq_str_content, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0002;
        }
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_dq_str_chunk) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_dq_str_chunk, &chunk->thunks, &(chunk->values.buf[1]), offset, offset_loc, l)) goto L0002;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_dq_str_content_0, 3, 0);
            thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
            thunk->data.leaf.values.buf[1] = &(chunk->values.buf[1]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            packcr_rule_set_t *l = NULL;
            if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_dq_str_chunk) == PACKCR_VOID_VALUE) {
                l = limits;
            }
            if (!packcr_apply_rule(ctx, packcr_evaluate_rule_dq_str_chunk, &chunk->thunks, &(chunk->values.buf[2]), offset, offset_loc, l)) goto L0003;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_dq_str_content_1, 3, 0);
            thunk->data.leaf.values.buf[2] = &(chunk->values.buf[2]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0003:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_dq_str_content_2, 3, 0);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
    L0001:;
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "dq_str_content", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_dq_str_chunk(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "dq_str_chunk", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 0);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 2);
    {
        const size_t p = ctx->position_offset;
        const packcr_location_t p_loc = ctx->position_offset_loc;
        const size_t n = chunk->thunks.len;
        {
            const size_t p = ctx->position_offset;
            size_t q;
            packcr_location_t p_loc = ctx->position_offset_loc;
            packcr_location_t q_loc;
            {
                const size_t p0 = ctx->position_offset;
                const packcr_location_t p0_loc = ctx->position_offset_loc;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->position_offset;
                    const packcr_location_t p_loc = ctx->position_offset_loc;
                    const size_t n = chunk->thunks.len;
                    {
                        const size_t p = ctx->position_offset;
                        const packcr_location_t p_loc = ctx->position_offset_loc;
                        const size_t n = chunk->thunks.len;
                        {
                            int u;
                            const size_t n = packcr_get_char_as_utf32(ctx, &u);
                            if (n == 0) goto L0005;
                            if (
                                u == 0x00005c ||
                                u == 0x000022 ||
                                u == 0x000023
                            ) goto L0005;
                            packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, n);
                            ctx->position_offset += n;
                        }
                        goto L0004;
                    L0005:;
                        ctx->position_offset = p;
                        ctx->position_offset_loc = p_loc;
                        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        if (
                            packcr_refill_buffer(ctx, 1) < 1 ||
                            ctx->buffer.buf[ctx->position_offset] != '#'
                        ) goto L0006;
                            packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
                        ctx->position_offset++;
                        {
                            int u;
                            const size_t n = packcr_get_char_as_utf32(ctx, &u);
                            if (n == 0) goto L0006;
                            if (
                                u == 0x00005c ||
                                u == 0x000022 ||
                                u == 0x00007b
                            ) goto L0006;
                            packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, n);
                            ctx->position_offset += n;
                        }
                        goto L0004;
                    L0006:;
                        ctx->position_offset = p;
                        ctx->position_offset_loc = p_loc;
                        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                        goto L0003;
                    L0004:;
                    }
                    if (ctx->position_offset == p) break;
                    continue;
                L0003:;
                    ctx->position_offset = p;
                    ctx->position_offset_loc = p_loc;
                    packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->position_offset = p0;
                    ctx->position_offset_loc = p0_loc;
                    packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                    goto L0002;
                }
            }
            q = ctx->position_offset;
            chunk->capts.buf[0].range.start = p;
            chunk->capts.buf[0].range.end = q;
            q_loc = ctx->position_offset_loc;
            chunk->capts.buf[0].range.start_loc = p_loc;
            chunk->capts.buf[0].range.end_loc = q_loc;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_dq_str_chunk_0, 0, 2);
            thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            const size_t p = ctx->position_offset;
            size_t q;
            packcr_location_t p_loc = ctx->position_offset_loc;
            packcr_location_t q_loc;
            {
                const size_t p = ctx->position_offset;
                const packcr_location_t p_loc = ctx->position_offset_loc;
                const size_t n = chunk->thunks.len;
                if (
                    packcr_refill_buffer(ctx, 2) < 2 ||
                    (ctx->buffer.buf + ctx->position_offset)[0] != '\\' ||
                    (ctx->buffer.buf + ctx->position_offset)[1] != '\\'
                ) goto L0009;
                packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 2);
                ctx->position_offset += 2;
                goto L0008;
            L0009:;
                ctx->position_offset = p;
                ctx->position_offset_loc = p_loc;
                packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                if (
                    packcr_refill_buffer(ctx, 2) < 2 ||
                    (ctx->buffer.buf + ctx->position_offset)[0] != '\\' ||
                    (ctx->buffer.buf + ctx->position_offset)[1] != '\"'
                ) goto L0010;
                packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 2);
                ctx->position_offset += 2;
                goto L0008;
            L0010:;
                ctx->position_offset = p;
                ctx->position_offset_loc = p_loc;
                packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                goto L0007;
            L0008:;
            }
            q = ctx->position_offset;
            chunk->capts.buf[1].range.start = p;
            chunk->capts.buf[1].range.end = q;
            q_loc = ctx->position_offset_loc;
            chunk->capts.buf[1].range.start_loc = p_loc;
            chunk->capts.buf[1].range.end_loc = q_loc;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_dq_str_chunk_1, 0, 2);
            thunk->data.leaf.capts.buf[1] = &(chunk->capts.buf[1]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0007:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "dq_str_chunk", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "dq_str_chunk", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_numeric(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "numeric", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_simple_numeric) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_simple_numeric, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_numeric_0, 1, 0);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "numeric", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "numeric", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_simple_numeric(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "simple_numeric", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 1);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    packcr_value_table__clear(ctx->auxil, &chunk->values);
    {
        packcr_rule_set_t *l = NULL;
        if (limits && ctx->position_offset == offset && packcr_rule_set__index(ctx->auxil, limits, packcr_evaluate_rule_tINTEGER) == PACKCR_VOID_VALUE) {
            l = limits;
        }
        if (!packcr_apply_rule(ctx, packcr_evaluate_rule_tINTEGER, &chunk->thunks, &(chunk->values.buf[0]), offset, offset_loc, l)) goto L0000;
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_simple_numeric_0, 1, 0);
        thunk->data.leaf.values.buf[0] = &(chunk->values.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "simple_numeric", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "simple_numeric", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_tINTEGER(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "tINTEGER", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 0);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 4);
    {
        const size_t p = ctx->position_offset;
        const packcr_location_t p_loc = ctx->position_offset_loc;
        const size_t n = chunk->thunks.len;
        if (
            packcr_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->position_offset] != '0'
        ) goto L0002;
            packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
        ctx->position_offset++;
        {
            int u;
            const size_t n = packcr_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0002;
            if (!(
                u == 0x000058 ||
                u == 0x000078
            )) goto L0002;
            packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, n);
            ctx->position_offset += n;
        }
        {
            const size_t p = ctx->position_offset;
            size_t q;
            packcr_location_t p_loc = ctx->position_offset_loc;
            packcr_location_t q_loc;
            {
                const size_t p0 = ctx->position_offset;
                const packcr_location_t p0_loc = ctx->position_offset_loc;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->position_offset;
                    const packcr_location_t p_loc = ctx->position_offset_loc;
                    const size_t n = chunk->thunks.len;
                    {
                        int u;
                        const size_t n = packcr_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0003;
                        if (!(
                            (u >= 0x000030 && u <= 0x000039) ||
                            (u >= 0x000061 && u <= 0x000066) ||
                            (u >= 0x000041 && u <= 0x000046)
                        )) goto L0003;
                        packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, n);
                        ctx->position_offset += n;
                    }
                    if (ctx->position_offset == p) break;
                    continue;
                L0003:;
                    ctx->position_offset = p;
                    ctx->position_offset_loc = p_loc;
                    packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->position_offset = p0;
                    ctx->position_offset_loc = p0_loc;
                    packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                    goto L0002;
                }
            }
            {
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->position_offset;
                    const packcr_location_t p_loc = ctx->position_offset_loc;
                    const size_t n = chunk->thunks.len;
                    {
                        const size_t p0 = ctx->position_offset;
                        const packcr_location_t p0_loc = ctx->position_offset_loc;
                        const size_t n0 = chunk->thunks.len;
                        int i;
                        for (i = 0;; i++) {
                            const size_t p = ctx->position_offset;
                            const packcr_location_t p_loc = ctx->position_offset_loc;
                            const size_t n = chunk->thunks.len;
                            if (
                                packcr_refill_buffer(ctx, 1) < 1 ||
                                ctx->buffer.buf[ctx->position_offset] != '_'
                            ) goto L0005;
                                packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
                            ctx->position_offset++;
                            if (ctx->position_offset == p) break;
                            continue;
                        L0005:;
                            ctx->position_offset = p;
                            ctx->position_offset_loc = p_loc;
                            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                            break;
                        }
                        if (i < 1) {
                            ctx->position_offset = p0;
                            ctx->position_offset_loc = p0_loc;
                            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                            goto L0004;
                        }
                    }
                    {
                        const size_t p0 = ctx->position_offset;
                        const packcr_location_t p0_loc = ctx->position_offset_loc;
                        const size_t n0 = chunk->thunks.len;
                        int i;
                        for (i = 0;; i++) {
                            const size_t p = ctx->position_offset;
                            const packcr_location_t p_loc = ctx->position_offset_loc;
                            const size_t n = chunk->thunks.len;
                            {
                                int u;
                                const size_t n = packcr_get_char_as_utf32(ctx, &u);
                                if (n == 0) goto L0006;
                                if (!(
                                    (u >= 0x000030 && u <= 0x000039) ||
                                    (u >= 0x000061 && u <= 0x000066) ||
                                    (u >= 0x000041 && u <= 0x000046)
                                )) goto L0006;
                                packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, n);
                                ctx->position_offset += n;
                            }
                            if (ctx->position_offset == p) break;
                            continue;
                        L0006:;
                            ctx->position_offset = p;
                            ctx->position_offset_loc = p_loc;
                            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                            break;
                        }
                        if (i < 1) {
                            ctx->position_offset = p0;
                            ctx->position_offset_loc = p0_loc;
                            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                            goto L0004;
                        }
                    }
                    if (ctx->position_offset == p) break;
                    continue;
                L0004:;
                    ctx->position_offset = p;
                    ctx->position_offset_loc = p_loc;
                    packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
            }
            q = ctx->position_offset;
            chunk->capts.buf[0].range.start = p;
            chunk->capts.buf[0].range.end = q;
            q_loc = ctx->position_offset_loc;
            chunk->capts.buf[0].range.start_loc = p_loc;
            chunk->capts.buf[0].range.end_loc = q_loc;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_tINTEGER_0, 0, 4);
            thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            packcr_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->position_offset] != '0'
        ) goto L0007;
            packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
        ctx->position_offset++;
        {
            int u;
            const size_t n = packcr_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0007;
            if (!(
                u == 0x00004f ||
                u == 0x00006f
            )) goto L0007;
            packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, n);
            ctx->position_offset += n;
        }
        {
            const size_t p = ctx->position_offset;
            size_t q;
            packcr_location_t p_loc = ctx->position_offset_loc;
            packcr_location_t q_loc;
            {
                const size_t p0 = ctx->position_offset;
                const packcr_location_t p0_loc = ctx->position_offset_loc;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->position_offset;
                    const packcr_location_t p_loc = ctx->position_offset_loc;
                    const size_t n = chunk->thunks.len;
                    {
                        int u;
                        const size_t n = packcr_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0008;
                        if (!(
                            (u >= 0x000030 && u <= 0x000037)
                        )) goto L0008;
                        packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, n);
                        ctx->position_offset += n;
                    }
                    if (ctx->position_offset == p) break;
                    continue;
                L0008:;
                    ctx->position_offset = p;
                    ctx->position_offset_loc = p_loc;
                    packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->position_offset = p0;
                    ctx->position_offset_loc = p0_loc;
                    packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                    goto L0007;
                }
            }
            {
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->position_offset;
                    const packcr_location_t p_loc = ctx->position_offset_loc;
                    const size_t n = chunk->thunks.len;
                    {
                        const size_t p0 = ctx->position_offset;
                        const packcr_location_t p0_loc = ctx->position_offset_loc;
                        const size_t n0 = chunk->thunks.len;
                        int i;
                        for (i = 0;; i++) {
                            const size_t p = ctx->position_offset;
                            const packcr_location_t p_loc = ctx->position_offset_loc;
                            const size_t n = chunk->thunks.len;
                            if (
                                packcr_refill_buffer(ctx, 1) < 1 ||
                                ctx->buffer.buf[ctx->position_offset] != '_'
                            ) goto L0010;
                                packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
                            ctx->position_offset++;
                            if (ctx->position_offset == p) break;
                            continue;
                        L0010:;
                            ctx->position_offset = p;
                            ctx->position_offset_loc = p_loc;
                            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                            break;
                        }
                        if (i < 1) {
                            ctx->position_offset = p0;
                            ctx->position_offset_loc = p0_loc;
                            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                            goto L0009;
                        }
                    }
                    {
                        const size_t p0 = ctx->position_offset;
                        const packcr_location_t p0_loc = ctx->position_offset_loc;
                        const size_t n0 = chunk->thunks.len;
                        int i;
                        for (i = 0;; i++) {
                            const size_t p = ctx->position_offset;
                            const packcr_location_t p_loc = ctx->position_offset_loc;
                            const size_t n = chunk->thunks.len;
                            {
                                int u;
                                const size_t n = packcr_get_char_as_utf32(ctx, &u);
                                if (n == 0) goto L0011;
                                if (!(
                                    u == 0x00005f ||
                                    (u >= 0x000030 && u <= 0x000037)
                                )) goto L0011;
                                packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, n);
                                ctx->position_offset += n;
                            }
                            if (ctx->position_offset == p) break;
                            continue;
                        L0011:;
                            ctx->position_offset = p;
                            ctx->position_offset_loc = p_loc;
                            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                            break;
                        }
                        if (i < 1) {
                            ctx->position_offset = p0;
                            ctx->position_offset_loc = p0_loc;
                            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                            goto L0009;
                        }
                    }
                    if (ctx->position_offset == p) break;
                    continue;
                L0009:;
                    ctx->position_offset = p;
                    ctx->position_offset_loc = p_loc;
                    packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
            }
            q = ctx->position_offset;
            chunk->capts.buf[1].range.start = p;
            chunk->capts.buf[1].range.end = q;
            q_loc = ctx->position_offset_loc;
            chunk->capts.buf[1].range.start_loc = p_loc;
            chunk->capts.buf[1].range.end_loc = q_loc;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_tINTEGER_1, 0, 4);
            thunk->data.leaf.capts.buf[1] = &(chunk->capts.buf[1]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0007:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            packcr_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->position_offset] != '0'
        ) goto L0012;
            packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
        ctx->position_offset++;
        {
            int u;
            const size_t n = packcr_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0012;
            if (!(
                u == 0x000042 ||
                u == 0x000062
            )) goto L0012;
            packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, n);
            ctx->position_offset += n;
        }
        {
            const size_t p = ctx->position_offset;
            size_t q;
            packcr_location_t p_loc = ctx->position_offset_loc;
            packcr_location_t q_loc;
            {
                const size_t p0 = ctx->position_offset;
                const packcr_location_t p0_loc = ctx->position_offset_loc;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->position_offset;
                    const packcr_location_t p_loc = ctx->position_offset_loc;
                    const size_t n = chunk->thunks.len;
                    {
                        int u;
                        const size_t n = packcr_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0013;
                        if (!(
                            u == 0x000030 ||
                            u == 0x000031
                        )) goto L0013;
                        packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, n);
                        ctx->position_offset += n;
                    }
                    if (ctx->position_offset == p) break;
                    continue;
                L0013:;
                    ctx->position_offset = p;
                    ctx->position_offset_loc = p_loc;
                    packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->position_offset = p0;
                    ctx->position_offset_loc = p0_loc;
                    packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                    goto L0012;
                }
            }
            {
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->position_offset;
                    const packcr_location_t p_loc = ctx->position_offset_loc;
                    const size_t n = chunk->thunks.len;
                    {
                        const size_t p0 = ctx->position_offset;
                        const packcr_location_t p0_loc = ctx->position_offset_loc;
                        const size_t n0 = chunk->thunks.len;
                        int i;
                        for (i = 0;; i++) {
                            const size_t p = ctx->position_offset;
                            const packcr_location_t p_loc = ctx->position_offset_loc;
                            const size_t n = chunk->thunks.len;
                            if (
                                packcr_refill_buffer(ctx, 1) < 1 ||
                                ctx->buffer.buf[ctx->position_offset] != '_'
                            ) goto L0015;
                                packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
                            ctx->position_offset++;
                            if (ctx->position_offset == p) break;
                            continue;
                        L0015:;
                            ctx->position_offset = p;
                            ctx->position_offset_loc = p_loc;
                            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                            break;
                        }
                        if (i < 1) {
                            ctx->position_offset = p0;
                            ctx->position_offset_loc = p0_loc;
                            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                            goto L0014;
                        }
                    }
                    {
                        const size_t p0 = ctx->position_offset;
                        const packcr_location_t p0_loc = ctx->position_offset_loc;
                        const size_t n0 = chunk->thunks.len;
                        int i;
                        for (i = 0;; i++) {
                            const size_t p = ctx->position_offset;
                            const packcr_location_t p_loc = ctx->position_offset_loc;
                            const size_t n = chunk->thunks.len;
                            {
                                int u;
                                const size_t n = packcr_get_char_as_utf32(ctx, &u);
                                if (n == 0) goto L0016;
                                if (!(
                                    u == 0x00005f ||
                                    u == 0x000030 ||
                                    u == 0x000031
                                )) goto L0016;
                                packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, n);
                                ctx->position_offset += n;
                            }
                            if (ctx->position_offset == p) break;
                            continue;
                        L0016:;
                            ctx->position_offset = p;
                            ctx->position_offset_loc = p_loc;
                            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                            break;
                        }
                        if (i < 1) {
                            ctx->position_offset = p0;
                            ctx->position_offset_loc = p0_loc;
                            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                            goto L0014;
                        }
                    }
                    if (ctx->position_offset == p) break;
                    continue;
                L0014:;
                    ctx->position_offset = p;
                    ctx->position_offset_loc = p_loc;
                    packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
            }
            q = ctx->position_offset;
            chunk->capts.buf[2].range.start = p;
            chunk->capts.buf[2].range.end = q;
            q_loc = ctx->position_offset_loc;
            chunk->capts.buf[2].range.start_loc = p_loc;
            chunk->capts.buf[2].range.end_loc = q_loc;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_tINTEGER_2, 0, 4);
            thunk->data.leaf.capts.buf[2] = &(chunk->capts.buf[2]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0012:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            if (
                packcr_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.buf[ctx->position_offset] != '0'
            ) goto L0018;
                packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
            ctx->position_offset++;
            {
                int u;
                const size_t n = packcr_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0018;
                if (!(
                    u == 0x000044 ||
                    u == 0x000064
                )) goto L0018;
                packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, n);
                ctx->position_offset += n;
            }
            goto L0019;
        L0018:;
            ctx->position_offset_loc = p_loc;
            ctx->position_offset = p;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0019:;
        }
        {
            const size_t p = ctx->position_offset;
            size_t q;
            packcr_location_t p_loc = ctx->position_offset_loc;
            packcr_location_t q_loc;
            {
                const size_t p0 = ctx->position_offset;
                const packcr_location_t p0_loc = ctx->position_offset_loc;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->position_offset;
                    const packcr_location_t p_loc = ctx->position_offset_loc;
                    const size_t n = chunk->thunks.len;
                    {
                        int u;
                        const size_t n = packcr_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0020;
                        if (!(
                            (u >= 0x000030 && u <= 0x000039)
                        )) goto L0020;
                        packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, n);
                        ctx->position_offset += n;
                    }
                    if (ctx->position_offset == p) break;
                    continue;
                L0020:;
                    ctx->position_offset = p;
                    ctx->position_offset_loc = p_loc;
                    packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->position_offset = p0;
                    ctx->position_offset_loc = p0_loc;
                    packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                    goto L0017;
                }
            }
            {
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->position_offset;
                    const packcr_location_t p_loc = ctx->position_offset_loc;
                    const size_t n = chunk->thunks.len;
                    {
                        const size_t p0 = ctx->position_offset;
                        const packcr_location_t p0_loc = ctx->position_offset_loc;
                        const size_t n0 = chunk->thunks.len;
                        int i;
                        for (i = 0;; i++) {
                            const size_t p = ctx->position_offset;
                            const packcr_location_t p_loc = ctx->position_offset_loc;
                            const size_t n = chunk->thunks.len;
                            if (
                                packcr_refill_buffer(ctx, 1) < 1 ||
                                ctx->buffer.buf[ctx->position_offset] != '_'
                            ) goto L0022;
                                packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
                            ctx->position_offset++;
                            if (ctx->position_offset == p) break;
                            continue;
                        L0022:;
                            ctx->position_offset = p;
                            ctx->position_offset_loc = p_loc;
                            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                            break;
                        }
                        if (i < 1) {
                            ctx->position_offset = p0;
                            ctx->position_offset_loc = p0_loc;
                            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                            goto L0021;
                        }
                    }
                    {
                        const size_t p0 = ctx->position_offset;
                        const packcr_location_t p0_loc = ctx->position_offset_loc;
                        const size_t n0 = chunk->thunks.len;
                        int i;
                        for (i = 0;; i++) {
                            const size_t p = ctx->position_offset;
                            const packcr_location_t p_loc = ctx->position_offset_loc;
                            const size_t n = chunk->thunks.len;
                            {
                                int u;
                                const size_t n = packcr_get_char_as_utf32(ctx, &u);
                                if (n == 0) goto L0023;
                                if (!(
                                    (u >= 0x000030 && u <= 0x000039)
                                )) goto L0023;
                                packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, n);
                                ctx->position_offset += n;
                            }
                            if (ctx->position_offset == p) break;
                            continue;
                        L0023:;
                            ctx->position_offset = p;
                            ctx->position_offset_loc = p_loc;
                            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                            break;
                        }
                        if (i < 1) {
                            ctx->position_offset = p0;
                            ctx->position_offset_loc = p0_loc;
                            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                            goto L0021;
                        }
                    }
                    if (ctx->position_offset == p) break;
                    continue;
                L0021:;
                    ctx->position_offset = p;
                    ctx->position_offset_loc = p_loc;
                    packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    break;
                }
            }
            q = ctx->position_offset;
            chunk->capts.buf[3].range.start = p;
            chunk->capts.buf[3].range.end = q;
            q_loc = ctx->position_offset_loc;
            chunk->capts.buf[3].range.start_loc = p_loc;
            chunk->capts.buf[3].range.end_loc = q_loc;
        }
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_tINTEGER_3, 0, 4);
            thunk->data.leaf.capts.buf[3] = &(chunk->capts.buf[3]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0017:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "tINTEGER", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "tINTEGER", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_tIDENTIFIER(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "tIDENTIFIER", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 0);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        int u;
        const size_t n = packcr_get_char_as_utf32(ctx, &u);
        if (n == 0) goto L0000;
        if (!(
            (u >= 0x000061 && u <= 0x00007a) ||
            u == 0x00005f
        )) goto L0000;
        packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, n);
        ctx->position_offset += n;
    }
    {
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                int u;
                const size_t n = packcr_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0001;
                if (!(
                    (u >= 0x000061 && u <= 0x00007a) ||
                    (u >= 0x000041 && u <= 0x00005a) ||
                    u == 0x00005f ||
                    (u >= 0x000030 && u <= 0x000039)
                )) goto L0001;
                packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, n);
                ctx->position_offset += n;
            }
            if (ctx->position_offset == p) break;
            continue;
        L0001:;
            ctx->position_offset = p;
            ctx->position_offset_loc = p_loc;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_tIDENTIFIER_0, 0, 0);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "tIDENTIFIER", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "tIDENTIFIER", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_tCONSTANT(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "tCONSTANT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 0);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        int u;
        const size_t n = packcr_get_char_as_utf32(ctx, &u);
        if (n == 0) goto L0000;
        if (!(
            (u >= 0x000041 && u <= 0x00005a)
        )) goto L0000;
        packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, n);
        ctx->position_offset += n;
    }
    {
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                int u;
                const size_t n = packcr_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0001;
                if (!(
                    (u >= 0x000061 && u <= 0x00007a) ||
                    (u >= 0x000041 && u <= 0x00005a) ||
                    u == 0x00005f ||
                    (u >= 0x000030 && u <= 0x000039)
                )) goto L0001;
                packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, n);
                ctx->position_offset += n;
            }
            if (ctx->position_offset == p) break;
            continue;
        L0001:;
            ctx->position_offset = p;
            ctx->position_offset_loc = p_loc;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_tCONSTANT_0, 0, 0);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->position_offset;
        thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
        thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
        packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "tCONSTANT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "tCONSTANT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_term(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "term", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 0);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const size_t p = ctx->position_offset;
        const packcr_location_t p_loc = ctx->position_offset_loc;
        const size_t n = chunk->thunks.len;
        if (
            packcr_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->position_offset] != ';'
        ) goto L0002;
            packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
        ctx->position_offset++;
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_term_0, 0, 0);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            packcr_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->position_offset] != '\n'
        ) goto L0003;
            packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, 1);
        ctx->position_offset++;
        {
            packcr_thunk_t *const thunk = packcr_thunk__create_leaf(ctx->auxil, packcr_action_term_1, 0, 0);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->position_offset;
            thunk->data.leaf.capt0.range.start_loc = chunk->pos_loc;
            thunk->data.leaf.capt0.range.end_loc = ctx->position_offset_loc;
            packcr_thunk_array__add(ctx->auxil, &chunk->thunks, thunk);
        }
        goto L0001;
    L0003:;
        ctx->position_offset = p;
        ctx->position_offset_loc = p_loc;
        packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "term", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "term", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_spaces(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "spaces", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 0);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const size_t p0 = ctx->position_offset;
        const packcr_location_t p0_loc = ctx->position_offset_loc;
        const size_t n0 = chunk->thunks.len;
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->position_offset;
            const packcr_location_t p_loc = ctx->position_offset_loc;
            const size_t n = chunk->thunks.len;
            {
                int u;
                const size_t n = packcr_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0001;
                if (!(
                    u == 0x000020 ||
                    u == 0x000009 ||
                    u == 0x00000b ||
                    u == 0x00000c ||
                    u == 0x00000d
                )) goto L0001;
                packcr_location_forward(&ctx->position_offset_loc, ctx->buffer.buf + ctx->position_offset, n);
                ctx->position_offset += n;
            }
            if (ctx->position_offset == p) break;
            continue;
        L0001:;
            ctx->position_offset = p;
            ctx->position_offset_loc = p_loc;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
        if (i < 1) {
            ctx->position_offset = p0;
            ctx->position_offset_loc = p0_loc;
            packcr_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
            goto L0000;
        }
    }
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "spaces", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "spaces", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static packcr_thunk_chunk_t *packcr_evaluate_rule_EOF(packcr_context_t *ctx, size_t offset, packcr_location_t offset_loc, packcr_rule_set_t *limits) {
    packcr_thunk_chunk_t *const chunk = packcr_thunk_chunk__create(ctx);
    chunk->pos = ctx->position_offset;
    chunk->pos_loc = ctx->position_offset_loc;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_EVALUATE, "EOF", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    packcr_value_table__resize(ctx->auxil, &chunk->values, 0);
    packcr_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (packcr_refill_buffer(ctx, 1) >= 1) goto L0000;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_MATCH, "EOF", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PACKCR_DEBUG(ctx->auxil, PACKCR_DBG_NOMATCH, "EOF", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->position_offset - chunk->pos));
    packcr_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

tiny_ruby_parser_context_t *tiny_ruby_parser_create(tiny_ruby_context_ext *auxil) {
    return packcr_context__create(auxil);
}

int tiny_ruby_parser_parse(tiny_ruby_parser_context_t *ctx, tiny_ruby_value *ret) {
    size_t pos = ctx->buffer_start_position;
    if (packcr_apply_rule(ctx, packcr_evaluate_rule_dump, &ctx->thunks, ret, ctx->position_offset, ctx->position_offset_loc, NULL))
        packcr_do_action(ctx, &ctx->thunks, ret);
    else
        PACKCR_ERROR(ctx->auxil);
    packcr_commit_buffer(ctx);
    packcr_thunk_array__revert(ctx->auxil, &ctx->thunks, 0);
    return pos != ctx->buffer_start_position && packcr_refill_buffer(ctx, 1) >= 1;
}

void tiny_ruby_parser_destroy(tiny_ruby_parser_context_t *ctx) {
    packcr_context__destroy(ctx);
}

VALUE parser_run(VALUE self) {
    tiny_ruby_context_ext auxil;
    tiny_ruby_parser_context_t *ctx = tiny_ruby_parser_create(&auxil);
    auxil.ctx = ctx;
    while (tiny_ruby_parser_parse(ctx, NULL));
    tiny_ruby_parser_destroy(ctx);
    return Qnil;
}

void Init_tiny_ruby_parser(void) {
    VALUE cTinyRubyParser = rb_define_class("TinyRubyParser", rb_cObject);
    rb_define_method(cTinyRubyParser, "run", parser_run, 0);
}
