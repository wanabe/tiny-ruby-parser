# A packrat parser generated by PackCR 0.0.8

# original file: https://git.ruby-lang.org/ruby.git/tree/parse.y

class TinyRubyParser
  class Location
    attr_reader :lineno, :column

    def initialize(lineno = 0, column = 0)
      @lineno = lineno
      @column = column
    end

    def +(other)
      if other.lineno == 0
        Location.new(@lineno + other.lineno, @column + other.column)
      else
        Location.new(@lineno + other.lineno,           other.column)
      end
    end

    def -(other)
      if other.lineno == self.lineno
        Location.new(@lineno - other.lineno, @column - other.column)
      elsif other.column == 0
        Location.new(@lineno - other.lineno, @column - other.column)
      else
        raise "unexpected location #{self.inspect} - #{other.inspect}"
      end
    end

    def forward(buffer, cur, n)
      Location.new(@lineno, @column).forward!(buffer, cur, n)
    end

    def forward!(buffer, cur, n)
      buffer[cur, n].scan(/(.*)(\n)?/) do
        if Regexp.last_match[2]
          @lineno += 1
          @column = 0
        else
          @column += Regexp.last_match[1].length
        end
      end
      self
    end
  end

    class << TinyRubyParser
    def block_append(head, tail)
      if !head
        return tail
      end
      head.block_append(tail)
    end

    def list_append(list, item)
      if !list
        return ListNode.new(item, item.nd_loc.beg_pos, item.nd_loc.end_pos)
      end

      if list.nd_next
        last = list.nd_next.nd_end
      else
        last = list
      end

      list.nd_alen += 1
      last.nd_next = ListNode.new(item, item.nd_loc.beg_pos, item.nd_loc.end_pos)
      list.nd_next.nd_end = last.nd_next

      list.nd_loc.end_pos = item.nd_loc.end_pos

      list
    end

    def set_defun_body(n, args, body, beg_pos, end_pos)
      args.var_table_pass(body)
      n.nd_defn = ScopeNode.new(args.var_table || [], body, args, beg_pos, end_pos)
      args.var_table = nil
      n.nd_loc.beg_pos = beg_pos
      n.nd_loc.end_pos = end_pos
      n
    end
  end

  class CodeLocation
    attr_accessor :beg_pos, :end_pos, :lineno

    def initialize(beg_pos, end_pos)
      @beg_pos = beg_pos
      @end_pos = end_pos
      @lineno = beg_pos.lineno
    end
  end

  NULL_LOC = CodeLocation.new(Location.new(0, -1), Location.new(0, -1))

  class Node
    attr_accessor :u1, :u2, :u3, :nd_loc, :node_id, :var_table
    attr_accessor :newline

    @current_id = 0
    class << self
      def next_id
        id = @current_id
        @current_id += 1
        id
      end

      def debug_dump(node, indent)
        if !node
          puts "#{indent}(null node)"
        else
          node.debug_dump(indent)
        end
      end

      def node_accessor(name, uname)
        alias_method name, uname
        alias_method :"#{name}=",  :"#{uname}="
      end
    end

    def initialize(u1, u2, u3, beg_pos, end_pos)
      @u1 = u1
      @u2 = u2
      @u3 = u3
      @nd_loc = CodeLocation.new(beg_pos, end_pos)
      @node_id = Node.next_id
    end

    def debug_dump(indent)
      puts "#{indent}@ #{label} (id: #{@node_id}, line: #{@nd_loc.lineno + 1}, location: (#{@nd_loc.beg_pos.lineno + 1},#{@nd_loc.beg_pos.column})-(#{@nd_loc.end_pos.lineno + 1},#{@nd_loc.end_pos.column}))#{newline ? "*" : ""}"
    end

    def to_block
      block_node = BlockNode.new(self, nd_loc.beg_pos, nd_loc.end_pos)
      block_node.var_table = self.var_table
      block_node
    end

    def block_append(tail)
      h = e = to_block
      e.nd_end = e
      head = e
      return head if !tail
      z = tail
      tail = tail.to_block
      raise z.inspect if !tail
      e.nd_next = tail
      h.nd_end = tail.nd_end
      head.nd_loc.end_pos = tail.nd_loc.end_pos
      head
    end

    def var_table_add(sym)
      @var_table ||= []
      @var_table << sym
    end

    def var_table_pass(src)
      return if !src
      if src.var_table
        if @var_table
          @var_table.concat(src.var_table)
        else
          @var_table = src.var_table
        end
      end
      src.var_table = nil
    end

    node_accessor :nd_head,  :u1
    node_accessor :nd_cpath, :u1
    node_accessor :nd_tbl,   :u1
    node_accessor :nd_vid,   :u1
    node_accessor :nd_alen,  :u2
    node_accessor :nd_end,   :u2
    node_accessor :nd_value, :u2
    node_accessor :nd_mid,   :u2
    node_accessor :nd_plen,  :u2
    node_accessor :nd_next,  :u3
    node_accessor :nd_args,  :u3
    node_accessor :nd_defn,  :u3
    node_accessor :nd_ainfo, :u3
    node_accessor :nd_super, :u3
  end

  class LitNode < Node
    def initialize(u1, beg_pos, end_pos)
      super(u1, nil, nil, beg_pos, end_pos)
    end

    def label
      "NODE_LIT"
    end

    def debug_dump(indent)
      super
      puts "#{indent}+- nd_lit: #{@u1.inspect}"
    end

    def block_append(tail)
      tail
    end
  end

  class StrNode < LitNode
    def label
      "NODE_STR"
    end
  end

  class ScopeNode < Node
    def label
      "NODE_SCOPE"
    end

    def debug_dump(indent)
      super
      print "#{indent}+- nd_tbl: "
      if @u1.empty?
        puts "(empty)"
      else
        puts @u1.map(&:inspect).join(",")
      end
      puts "#{indent}+- nd_args:"
      Node.debug_dump(nd_args, indent + "|   ")
      puts "#{indent}+- nd_body:"
      Node.debug_dump(@u2, indent + "    ")
    end
  end

  class ListNode < Node
    def initialize(u1, beg_pos, end_pos)
      super(u1, 1, nil, beg_pos, end_pos)
    end

    def label
      "NODE_LIST"
    end

    def debug_dump(indent)
      super

      puts "#{indent}+- nd_alen: #{@u2}"
      n = self
      begin
        puts "#{indent}+- nd_head:"
        Node.debug_dump(n.u1, indent + "|   ")
        n = n.nd_next
      end while n
      puts "#{indent}+- nd_next:",
           "#{indent}    (null node)"
    end
  end

  class CallNode < Node
    def label
      "NODE_CALL"
    end

    def debug_dump_recv(indent)
      puts "#{indent}+- nd_recv:"
      Node.debug_dump(@u1, indent + "|   ")
    end

    def debug_dump(indent)
      super
      puts "#{indent}+- nd_mid: #{u2.inspect}"
      debug_dump_recv(indent)
      puts "#{indent}+- nd_args:"
      Node.debug_dump(@u3, indent + "    ")
    end
  end

  class QCallNode < CallNode
    def label
      "NODE_QCALL"
    end
  end

  class FCallNode < CallNode
    def initialize(u2, u3, beg_pos, end_pos)
      super(nil, u2, u3, beg_pos, end_pos)
    end

    def label
      "NODE_FCALL"
    end

    def debug_dump_recv(...)
    end
  end

  class OpCallNode < CallNode
    def label
      "NODE_OPCALL"
    end
  end

  class BlockNode < Node
    def initialize(u1, beg_pos, end_pos)
      super(u1, self, nil, beg_pos, end_pos)
    end

    def label
      "NODE_BLOCK"
    end

    def to_block
      self
    end

    def block_append(tail)
      e = nd_end
      return self if !tail
      tail = tail.to_block
      e.nd_next = tail
      self.nd_end = tail.nd_end
      self.nd_loc.end_pos = tail.nd_loc.end_pos
      self
    end

    def debug_dump(indent)
      super
      child_indent = indent + "|   "
      n = self
      i = 1
      while n
        puts "#{indent}+- nd_head (#{i}):"
        if n == nd_end
          child_indent = indent + "    "
        end
        Node.debug_dump(n.nd_head, child_indent)
        i += 1
        n = n.nd_next
      end
    end
  end

  class SelfNode < Node
  end

  class DefnNode < Node
    def initialize(u2, u3, beg_pos, end_pos)
      super(nil, u2, u3, beg_pos, end_pos)
    end

    def label
      "NODE_DEFN"
    end

    def debug_dump(indent)
      super
      puts "#{indent}+- nd_mid: #{u2.inspect}"
      puts "#{indent}+- nd_defn:"
      Node.debug_dump(@u3, indent + "    ")
    end
  end

  class ArgsInfo
    attr_accessor :pre_args_num

    def initialize
      @pre_args_num = 0
    end
  end

  class ArgsAuxNode < Node
    def initialize(u1, u2, beg_pos, end_pos)
      super(u1, u2, nil, beg_pos, end_pos)
    end
  end

  class ArgsNode < Node
    def label
      "NODE_ARGS"
    end

    def debug_dump(indent)
      super
      puts "#{indent}+- nd_ainfo->pre_args_num: #{@u3.pre_args_num}"
      puts "#{indent}+- nd_ainfo->pre_init:"
      puts "#{indent}|   (null node)"
      puts "#{indent}+- nd_ainfo->post_args_num: 0"
      puts "#{indent}+- nd_ainfo->post_init:"
      puts "#{indent}|   (null node)"
      puts "#{indent}+- nd_ainfo->first_post_arg: (null)"
      puts "#{indent}+- nd_ainfo->rest_arg: (null)"
      puts "#{indent}+- nd_ainfo->block_arg: (null)"
      puts "#{indent}+- nd_ainfo->opt_args:"
      puts "#{indent}|   (null node)"
      puts "#{indent}+- nd_ainfo->kw_args:"
      puts "#{indent}|   (null node)"
      puts "#{indent}+- nd_ainfo->kw_rest_arg:"
      puts "#{indent}    (null node)"
    end
  end

  class LasgnNode < Node
    def initialize(u1, u2, beg_pos, end_pos)
      super(u1, u2, nil, beg_pos, end_pos)
    end

    def label
      "NODE_LASGN"
    end

    def debug_dump(indent)
      super
      puts "#{indent}+- nd_vid: #{nd_vid.inspect}"
      puts "#{indent}+- nd_value:"
      Node.debug_dump(nd_value, indent + "    ")
    end
  end

  class BeginNode < Node
    def label
      "NODE_BEGIN"
    end

    def debug_dump(indent)
      super
      puts "#{indent}+- nd_body:"
      Node.debug_dump(@u2, indent + "    ")
    end
  end

  class ClassNode < Node
    def label
      "NODE_CLASS"
    end

    def debug_dump(indent)
      super
      puts "#{indent}+- nd_cpath:"
      Node.debug_dump(nd_cpath, indent + "|   ")
      puts "#{indent}+- nd_super:"
      Node.debug_dump(nd_super, indent + "|   ")
      puts "#{indent}+- nd_body:"
      Node.debug_dump(@u2, indent + "    ")
    end
  end

  class Colon2Node < Node
    def initialize(u1, u2, beg_pos, end_pos)
      super(u1, u2, nil, beg_pos, end_pos)
    end

    def label
      "NODE_COLON2"
    end

    def debug_dump(indent)
      super
      puts "#{indent}+- nd_mid: #{u2.inspect}"
      puts "#{indent}+- nd_head:"
      Node.debug_dump(@u1, indent + "    ")
    end
  end

  def initialize(debug: false)
    @buffer = +""

    @buffer_start_position = 0
    @position_offset = 0
    @level = 0
    @thunk = ThunkNode.new([], nil, 0)
    @memos = LrMemoTable.new
    @debug = debug
    @global_values = {}
    @buffer_start_position_loc = Location.new
    @position_offset_loc = Location.new
  end

  def debug
    yield if @debug
  end

  def getc
    $stdin.getc
  end

  def refill_buffer(num, mode = nil)
    len = @buffer.length
    if len >= @position_offset + num
      return len - @position_offset
    end
    while len < @position_offset + num
      c = getc
      break if !c
      @buffer << c
      len = @buffer.length
    end
    return len - @position_offset
  end

  def commit_buffer
    @buffer = @buffer[@position_offset, @buffer.length - @position_offset]
    @buffer_start_position += @position_offset
    @memos.clear
    @position_offset = 0
    @buffer_start_position_loc = @buffer_start_position_loc + @position_offset_loc
    @position_offset_loc = Location.new
  end

  def parse
    pos = @buffer_start_position
    if apply_rule(:evaluate_rule_dump, @thunk.thunks, nil, 0, @buffer_start_position, @buffer_start_position_loc)
      @thunk.do_action(self, nil, 0)
    else
      raise SyntaxError, "can't parse"
    end
    commit_buffer
    @thunk.clear
    refill_buffer(1) >= 1 && pos != @buffer_start_position
  end

  def run
    nil while parse
  end

  def action_dump_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    program = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    program.debug_dump("# ")

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_program_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_top_compstmt_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    top_stmts = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    __1 = __packcr_in.capts[0].capture_string(@buffer)
    __1s = @buffer_start_position + __packcr_in.capts[0].range_start
    __1e = @buffer_start_position + __packcr_in.capts[0].range_end
    __1sl = @buffer_start_position_loc + __packcr_in.capts[0].start_loc
    __1el = @buffer_start_position_loc + __packcr_in.capts[0].end_loc
    __1c = __packcr_in.capts[0]
    ____ = ScopeNode.new(top_stmts.var_table || [], top_stmts, nil, top_stmts.nd_loc.beg_pos, top_stmts.nd_loc.end_pos)

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_top_stmts_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    top_stmts = (__packcr_in.value_refs[0]  ||= Value.new).value
    top_stmt = (__packcr_in.value_refs[1]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    top_stmt.newline = true
    ____ = TinyRubyParser.block_append(top_stmts, top_stmt)
    ____.var_table_pass(top_stmt)

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_top_stmts_1(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    top_stmt = (__packcr_in.value_refs[1]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    top_stmt.newline = true;
    ____ = top_stmt

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_top_stmts_2(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = BeginNode.new(nil, nil, nil, __0sl, __0sl)

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_top_stmt_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_stmt_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_compstmt_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_bodystmt_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_stmts_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    stmts = (__packcr_in.value_refs[0]  ||= Value.new).value
    stmt = (__packcr_in.value_refs[1]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    stmt.newline = true
    ____ = TinyRubyParser.block_append(stmts, stmt)
    ____.var_table_pass(stmt)

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_stmts_1(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    stmt = (__packcr_in.value_refs[1]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    stmt.newline = true
    ____ = stmt

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_expr_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_expr_1(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_command_call_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_command_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    fcall = (__packcr_in.value_refs[0]  ||= Value.new).value
    command_args = (__packcr_in.value_refs[1]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    fcall.nd_args = command_args
    fcall.nd_loc.beg_pos = __0c.start_loc
    fcall.nd_loc.end_pos = __0c.end_loc
    ____ = fcall

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_method_call_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    fcall = (__packcr_in.value_refs[0]  ||= Value.new).value
    paren_args = (__packcr_in.value_refs[1]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = fcall
    ____.nd_args = paren_args
    ____.nd_loc.end_pos = __0c.end_loc

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_method_call_1(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    primary = (__packcr_in.value_refs[2]  ||= Value.new).value
    call_op = (__packcr_in.value_refs[3]  ||= Value.new).value
    operation2 = (__packcr_in.value_refs[4]  ||= Value.new).value
    paren_args = (__packcr_in.value_refs[1]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    __1 = __packcr_in.capts[0].capture_string(@buffer)
    __1s = @buffer_start_position + __packcr_in.capts[0].range_start
    __1e = @buffer_start_position + __packcr_in.capts[0].range_end
    __1sl = @buffer_start_position_loc + __packcr_in.capts[0].start_loc
    __1el = @buffer_start_position_loc + __packcr_in.capts[0].end_loc
    __1c = __packcr_in.capts[0]
    ____ = paren_args

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_method_call_2(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    primary = (__packcr_in.value_refs[2]  ||= Value.new).value
    call_op = (__packcr_in.value_refs[3]  ||= Value.new).value
    operation2 = (__packcr_in.value_refs[4]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    __1 = __packcr_in.capts[0].capture_string(@buffer)
    __1s = @buffer_start_position + __packcr_in.capts[0].range_start
    __1e = @buffer_start_position + __packcr_in.capts[0].range_end
    __1sl = @buffer_start_position_loc + __packcr_in.capts[0].start_loc
    __1el = @buffer_start_position_loc + __packcr_in.capts[0].end_loc
    __1c = __packcr_in.capts[0]
    ____ = nil

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_method_call_3(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    primary = (__packcr_in.value_refs[2]  ||= Value.new).value
    call_op = (__packcr_in.value_refs[3]  ||= Value.new).value
    operation2 = (__packcr_in.value_refs[4]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    __1 = __packcr_in.capts[0].capture_string(@buffer)
    __1s = @buffer_start_position + __packcr_in.capts[0].range_start
    __1e = @buffer_start_position + __packcr_in.capts[0].range_end
    __1sl = @buffer_start_position_loc + __packcr_in.capts[0].start_loc
    __1el = @buffer_start_position_loc + __packcr_in.capts[0].end_loc
    __1c = __packcr_in.capts[0]
    ____ = call_op.new(primary, operation2, ____, __0sl, __0el)
    ____.nd_loc.lineno = __1el.lineno

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_fcall_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    operation = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = FCallNode.new(operation, nil, __0sl, __0el)

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_fname_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_fname_1(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_fname_2(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_operation_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_operation2_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_operation2_1(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_op_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = __0.to_sym

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_call_op_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = CallNode

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_call_op_1(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = QCallNode

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_command_args_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_paren_args_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_call_args_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_args_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    args = (__packcr_in.value_refs[0]  ||= Value.new).value
    arg_value = (__packcr_in.value_refs[1]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = TinyRubyParser.list_append(args, arg_value)

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_args_1(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    arg_value = (__packcr_in.value_refs[1]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = ListNode.new(arg_value, __0sl, __0el)

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_arg_value_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_arg_rhs_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_arg_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_arg_1(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    lhs = (__packcr_in.value_refs[1]  ||= Value.new).value
    arg = (__packcr_in.value_refs[2]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = LasgnNode.new(lhs, arg, __0sl, __0el)
    ____.var_table_add(lhs)

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_arg_addsub_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    recv = (__packcr_in.value_refs[0]  ||= Value.new).value
    arg = (__packcr_in.value_refs[1]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    __1 = __packcr_in.capts[0].capture_string(@buffer)
    __1s = @buffer_start_position + __packcr_in.capts[0].range_start
    __1e = @buffer_start_position + __packcr_in.capts[0].range_end
    __1sl = @buffer_start_position_loc + __packcr_in.capts[0].start_loc
    __1el = @buffer_start_position_loc + __packcr_in.capts[0].end_loc
    __1c = __packcr_in.capts[0]
    args = ListNode.new(arg, arg.nd_loc.beg_pos, arg.nd_loc.end_pos)
    ____ = OpCallNode.new(recv, __1.to_sym, args, __0sl, __0el)

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_arg_addsub_1(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[2]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_arg_muldiv_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    recv = (__packcr_in.value_refs[0]  ||= Value.new).value
    arg = (__packcr_in.value_refs[1]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    __1 = __packcr_in.capts[0].capture_string(@buffer)
    __1s = @buffer_start_position + __packcr_in.capts[0].range_start
    __1e = @buffer_start_position + __packcr_in.capts[0].range_end
    __1sl = @buffer_start_position_loc + __packcr_in.capts[0].start_loc
    __1el = @buffer_start_position_loc + __packcr_in.capts[0].end_loc
    __1c = __packcr_in.capts[0]
    args = ListNode.new(arg, arg.nd_loc.beg_pos, arg.nd_loc.end_pos)
    ____ = OpCallNode.new(recv, __1.to_sym, args, __0sl, __0el)

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_arg_muldiv_1(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[2]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_arg_primary_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_primary_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    defn_head = (__packcr_in.value_refs[0]  ||= Value.new).value
    f_arglist = (__packcr_in.value_refs[1]  ||= Value.new).value
    bodystmt = (__packcr_in.value_refs[2]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    if f_arglist.nd_head
      body = TinyRubyParser.block_append(f_arglist.nd_head, bodystmt)
      f_arglist.nd_head = nil
      body.var_table_pass(bodystmt)
    else
      body = bodystmt
    end
    ____ = TinyRubyParser.set_defun_body(defn_head, f_arglist, body, __0sl, __0el);
    ____.var_table_pass(body)

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_primary_1(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    cpath = (__packcr_in.value_refs[3]  ||= Value.new).value
    bodystmt = (__packcr_in.value_refs[2]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    __1 = __packcr_in.capts[0].capture_string(@buffer)
    __1s = @buffer_start_position + __packcr_in.capts[0].range_start
    __1e = @buffer_start_position + __packcr_in.capts[0].range_end
    __1sl = @buffer_start_position_loc + __packcr_in.capts[0].start_loc
    __1el = @buffer_start_position_loc + __packcr_in.capts[0].end_loc
    __1c = __packcr_in.capts[0]
    __2 = __packcr_in.capts[1].capture_string(@buffer)
    __2s = @buffer_start_position + __packcr_in.capts[1].range_start
    __2e = @buffer_start_position + __packcr_in.capts[1].range_end
    __2sl = @buffer_start_position_loc + __packcr_in.capts[1].start_loc
    __2el = @buffer_start_position_loc + __packcr_in.capts[1].end_loc
    __2c = __packcr_in.capts[1]
    if __2 != ""
      body = TinyRubyParser.block_append(BeginNode.new(nil, nil, nil, __1sl, __1sl), bodystmt)
      body.var_table_pass(bodystmt)
    else
      body = bodystmt
    end
    ____ = ClassNode.new(cpath, ScopeNode.new([], body, nil, __0sl, __0el), nil, __0sl, __0el)

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_primary_2(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[4]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_primary_3(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[4]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_primary_4(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[4]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_primary_5(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[4]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_defn_head_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    def_name = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = DefnNode.new(def_name.nd_mid, def_name, __0sl, __0el)

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_def_name_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    fname = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = SelfNode.new(nil, fname, nil, __0sl, __0el)

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_f_arglist_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    f_paren_args = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    __1 = __packcr_in.capts[0].capture_string(@buffer)
    __1s = @buffer_start_position + __packcr_in.capts[0].range_start
    __1e = @buffer_start_position + __packcr_in.capts[0].range_end
    __1sl = @buffer_start_position_loc + __packcr_in.capts[0].start_loc
    __1el = @buffer_start_position_loc + __packcr_in.capts[0].end_loc
    __1c = __packcr_in.capts[0]
    __2 = __packcr_in.capts[1].capture_string(@buffer)
    __2s = @buffer_start_position + __packcr_in.capts[1].range_start
    __2e = @buffer_start_position + __packcr_in.capts[1].range_end
    __2sl = @buffer_start_position_loc + __packcr_in.capts[1].start_loc
    __2el = @buffer_start_position_loc + __packcr_in.capts[1].end_loc
    __2c = __packcr_in.capts[1]
    ____ = f_paren_args
    if __2 != ""
      ____.nd_head = BeginNode.new(nil, nil, nil, __1sl, __1sl)
    end

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_f_arglist_1(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    f_args = (__packcr_in.value_refs[1]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    __3 = __packcr_in.capts[2].capture_string(@buffer)
    __3s = @buffer_start_position + __packcr_in.capts[2].range_start
    __3e = @buffer_start_position + __packcr_in.capts[2].range_end
    __3sl = @buffer_start_position_loc + __packcr_in.capts[2].start_loc
    __3el = @buffer_start_position_loc + __packcr_in.capts[2].end_loc
    __3c = __packcr_in.capts[2]
    __4 = __packcr_in.capts[3].capture_string(@buffer)
    __4s = @buffer_start_position + __packcr_in.capts[3].range_start
    __4e = @buffer_start_position + __packcr_in.capts[3].range_end
    __4sl = @buffer_start_position_loc + __packcr_in.capts[3].start_loc
    __4el = @buffer_start_position_loc + __packcr_in.capts[3].end_loc
    __4c = __packcr_in.capts[3]
    ____ = f_args
    if __4 != ""
      ____.nd_head = BeginNode.new(nil, nil, nil, __3sl, __3sl)
    end

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_f_paren_args_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_f_args_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    f_arg = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    args = ArgsInfo.new
    args.pre_args_num = f_arg.var_table.size
    ____ = ArgsNode.new(nil, nil, args, __0sl, __0el)
    ____.var_table_pass(f_arg)

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_f_args_1(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    args = ArgsInfo.new
    ____ = ArgsNode.new(nil, nil, args, __0sl, __0el)

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_f_arg_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    f_arg = (__packcr_in.value_refs[0]  ||= Value.new).value
    f_arg_item = (__packcr_in.value_refs[1]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = f_arg
    ____.nd_plen += 1
    ____.nd_next = TinyRubyParser.block_append(____.nd_next, f_arg_item.nd_next)
    ____.var_table_pass(f_arg_item)

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_f_arg_1(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[2]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_f_arg_item_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    f_arg_asgn = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = ArgsAuxNode.new(f_arg_asgn, 1, NULL_LOC.beg_pos, NULL_LOC.end_pos)
    ____.var_table_add(f_arg_asgn)

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_f_arg_asgn_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_f_norm_arg_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_cpath_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    cname = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = Colon2Node.new(nil, cname, __0sl, __0el)

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_literal_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_strings_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_string_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_string1_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    string_content = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = StrNode.new(string_content, __0sl, __0el)

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_string1_1(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    string_content = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    __1 = __packcr_in.capts[0].capture_string(@buffer)
    __1s = @buffer_start_position + __packcr_in.capts[0].range_start
    __1e = @buffer_start_position + __packcr_in.capts[0].range_end
    __1sl = @buffer_start_position_loc + __packcr_in.capts[0].start_loc
    __1el = @buffer_start_position_loc + __packcr_in.capts[0].end_loc
    __1c = __packcr_in.capts[0]
    str = string_content
    if __1 != ""
      str.concat(__1)
    end
    ____ = StrNode.new(string_content, __0sl, __0el)

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_sq_str_content_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    sq_str_content = (__packcr_in.value_refs[0]  ||= Value.new).value
    sq_str_chunk = (__packcr_in.value_refs[1]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = sq_str_content.concat(sq_str_chunk)

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_sq_str_content_1(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[2]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_sq_str_content_2(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = ""

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_sq_str_chunk_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    __1 = __packcr_in.capts[0].capture_string(@buffer)
    __1s = @buffer_start_position + __packcr_in.capts[0].range_start
    __1e = @buffer_start_position + __packcr_in.capts[0].range_end
    __1sl = @buffer_start_position_loc + __packcr_in.capts[0].start_loc
    __1el = @buffer_start_position_loc + __packcr_in.capts[0].end_loc
    __1c = __packcr_in.capts[0]
    ____ = __1

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_sq_str_chunk_1(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    __2 = __packcr_in.capts[1].capture_string(@buffer)
    __2s = @buffer_start_position + __packcr_in.capts[1].range_start
    __2e = @buffer_start_position + __packcr_in.capts[1].range_end
    __2sl = @buffer_start_position_loc + __packcr_in.capts[1].start_loc
    __2el = @buffer_start_position_loc + __packcr_in.capts[1].end_loc
    __2c = __packcr_in.capts[1]
    ____ = __2[1, 1]

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_dq_str_content_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    dq_str_content = (__packcr_in.value_refs[0]  ||= Value.new).value
    dq_str_chunk = (__packcr_in.value_refs[1]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = dq_str_content.concat(dq_str_chunk)

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_dq_str_content_1(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[2]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_dq_str_content_2(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = ""

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_dq_str_chunk_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    __1 = __packcr_in.capts[0].capture_string(@buffer)
    __1s = @buffer_start_position + __packcr_in.capts[0].range_start
    __1e = @buffer_start_position + __packcr_in.capts[0].range_end
    __1sl = @buffer_start_position_loc + __packcr_in.capts[0].start_loc
    __1el = @buffer_start_position_loc + __packcr_in.capts[0].end_loc
    __1c = __packcr_in.capts[0]
    ____ = __1

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_dq_str_chunk_1(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    __2 = __packcr_in.capts[1].capture_string(@buffer)
    __2s = @buffer_start_position + __packcr_in.capts[1].range_start
    __2e = @buffer_start_position + __packcr_in.capts[1].range_end
    __2sl = @buffer_start_position_loc + __packcr_in.capts[1].start_loc
    __2el = @buffer_start_position_loc + __packcr_in.capts[1].end_loc
    __2c = __packcr_in.capts[1]
    ____ = __2[1, 1]

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_numeric_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_simple_numeric_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    _out = (__packcr_in.value_refs[0]  ||= Value.new).value
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = _out

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_tINTEGER_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    __1 = __packcr_in.capts[0].capture_string(@buffer)
    __1s = @buffer_start_position + __packcr_in.capts[0].range_start
    __1e = @buffer_start_position + __packcr_in.capts[0].range_end
    __1sl = @buffer_start_position_loc + __packcr_in.capts[0].start_loc
    __1el = @buffer_start_position_loc + __packcr_in.capts[0].end_loc
    __1c = __packcr_in.capts[0]
    ____ = LitNode.new(__1.gsub("_", "").to_i(16), __0sl, __0el)

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_tINTEGER_1(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    __2 = __packcr_in.capts[1].capture_string(@buffer)
    __2s = @buffer_start_position + __packcr_in.capts[1].range_start
    __2e = @buffer_start_position + __packcr_in.capts[1].range_end
    __2sl = @buffer_start_position_loc + __packcr_in.capts[1].start_loc
    __2el = @buffer_start_position_loc + __packcr_in.capts[1].end_loc
    __2c = __packcr_in.capts[1]
    ____ = LitNode.new(__2.gsub("_", "").to_i(8), __0sl, __0el)

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_tINTEGER_2(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    __3 = __packcr_in.capts[2].capture_string(@buffer)
    __3s = @buffer_start_position + __packcr_in.capts[2].range_start
    __3e = @buffer_start_position + __packcr_in.capts[2].range_end
    __3sl = @buffer_start_position_loc + __packcr_in.capts[2].start_loc
    __3el = @buffer_start_position_loc + __packcr_in.capts[2].end_loc
    __3c = __packcr_in.capts[2]
    ____ = LitNode.new(__3.gsub("_", "").to_i(2), __0sl, __0el)

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_tINTEGER_3(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    __4 = __packcr_in.capts[3].capture_string(@buffer)
    __4s = @buffer_start_position + __packcr_in.capts[3].range_start
    __4e = @buffer_start_position + __packcr_in.capts[3].range_end
    __4sl = @buffer_start_position_loc + __packcr_in.capts[3].start_loc
    __4el = @buffer_start_position_loc + __packcr_in.capts[3].end_loc
    __4c = __packcr_in.capts[3]
    ____ = LitNode.new(__4.gsub("_", "").to_i, __0sl, __0el)

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_tIDENTIFIER_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = __0.to_sym

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_tCONSTANT_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = __0.to_sym

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_term_0(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = ';'

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def action_term_1(__packcr_in, __packcr_vars, __packcr_index)
    ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
    __0 = __packcr_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __packcr_in.capt0.range_start
    __0e = @buffer_start_position + __packcr_in.capt0.range_end
    __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
    __0c = __packcr_in.capt0
    ____ = '\n'

    __packcr_vars[__packcr_index].value = ____ if __packcr_vars
  end

  def evaluate_rule_dump(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    dump #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if limits && @position_offset == offset && !limits[:evaluate_rule_program]
        if !apply_rule(:evaluate_rule_program, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_program, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_dump_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0),
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   dump #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH dump #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_program(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    program #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if limits && @position_offset == offset && !limits[:evaluate_rule_top_compstmt]
        if !apply_rule(:evaluate_rule_top_compstmt, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_top_compstmt, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_program_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0),
          {},
        )
      )
      i3 = 0
      pos3 = nil
      p_loc3 = nil
      n3 = nil
      catch(1) do
        pos3 = @position_offset
        p_loc3 = @position_offset_loc
        n3 = answer.thunks.length
        if (
          refill_buffer(1) < 1 ||
          @buffer[@position_offset] != "\n"
        )
          throw(1)
        end
        @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
        @position_offset += 1
        i3 += 1
        if @position_offset != pos3
          redo
        end
        pos3 = nil
      end
      if pos3
        @position_offset = pos3
        @position_offset_loc = p_loc3
        answer.thunks[n3..-1] = []
      end
      if limits && @position_offset == offset && !limits[:evaluate_rule_EOF]
        if !apply_rule(:evaluate_rule_EOF, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_EOF, answer.thunks, nil, 0, offset, offset_loc)
          throw(0)
        end
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   program #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH program #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_top_compstmt(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    top_compstmt #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(1)
    answer.values = {}
    catch(0) do
      pos3 = @position_offset
      p_loc3 = @position_offset_loc
      if limits && @position_offset == offset && !limits[:evaluate_rule_top_stmts]
        if !apply_rule(:evaluate_rule_top_stmts, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_top_stmts, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      q3 = @position_offset
      capt3 = answer.capts[0]
      capt3.range_start = pos3
      capt3.range_end = q3
      q_loc3 = @position_offset_loc
      capt3.start_loc = p_loc3
      capt3.end_loc = q_loc3
      i3 = 0
      pos3 = nil
      p_loc3 = nil
      n3 = nil
      catch(1) do
        pos3 = @position_offset
        p_loc3 = @position_offset_loc
        n3 = answer.thunks.length
        if limits && @position_offset == offset && !limits[:evaluate_rule_term]
          if !apply_rule(:evaluate_rule_term, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
            throw(1)
          end
        else
          if !apply_rule(:evaluate_rule_term, answer.thunks, nil, 0, offset, offset_loc)
            throw(1)
          end
        end
        i3 += 1
        if @position_offset != pos3
          redo
        end
        pos3 = nil
      end
      if pos3
        @position_offset = pos3
        @position_offset_loc = p_loc3
        answer.thunks[n3..-1] = []
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_top_compstmt_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0),
          answer.capts.slice(0),
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   top_compstmt #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH top_compstmt #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_top_stmts(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    top_stmts #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(1) do
      pos2 = @position_offset
      p_loc2 = @position_offset_loc
      n2 = answer.thunks.length
      catch(2) do
        if limits && @position_offset == offset && !limits[:evaluate_rule_top_stmts]
          if !apply_rule(:evaluate_rule_top_stmts, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
            throw(2)
          end
        else
          if !apply_rule(:evaluate_rule_top_stmts, answer.thunks, answer.values, 0, offset, offset_loc)
            throw(2)
          end
        end
        pos4 = @position_offset
        p_loc4 = @position_offset_loc
        n4 = answer.thunks.length
        catch(4) do
          catch(3) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
              if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(3)
              end
            else
              if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
                throw(3)
              end
            end
            throw(4)
          end
          @position_offset_loc = p_loc4
          @position_offset = pos4
          answer.thunks[n4..-1] = []
        end
        q4 = @position_offset
        q_loc4 = @position_offset_loc
        m4 = answer.thunks.length
        i4 = 0
        pos4 = nil
        p_loc4 = nil
        n4 = nil
        catch(5) do
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          n4 = answer.thunks.length
          if limits && @position_offset == offset && !limits[:evaluate_rule_term]
            if !apply_rule(:evaluate_rule_term, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
              throw(5)
            end
          else
            if !apply_rule(:evaluate_rule_term, answer.thunks, nil, 0, offset, offset_loc)
              throw(5)
            end
          end
          i4 += 1
          if @position_offset != pos4
            redo
          end
          pos4 = nil
        end
        if pos4
          @position_offset = pos4
          @position_offset_loc = p_loc4
          answer.thunks[n4..-1] = []
        end
        if i4 < 1
          @position_offset = q4
          @position_offset_loc = q_loc4
          answer.thunks[m4..-1] = []
          throw(2)
        end
        pos4 = @position_offset
        p_loc4 = @position_offset_loc
        n4 = answer.thunks.length
        catch(7) do
          catch(6) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
              if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(6)
              end
            else
              if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
                throw(6)
              end
            end
            throw(7)
          end
          @position_offset_loc = p_loc4
          @position_offset = pos4
          answer.thunks[n4..-1] = []
        end
        if limits && @position_offset == offset && !limits[:evaluate_rule_top_stmt]
          if !apply_rule(:evaluate_rule_top_stmt, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
            throw(2)
          end
        else
          if !apply_rule(:evaluate_rule_top_stmt, answer.thunks, answer.values, 1, offset, offset_loc)
            throw(2)
          end
        end
        answer.thunks.push(
          ThunkLeaf.new(
            :action_top_stmts_0,
            Capture.new(
              answer.pos, @position_offset,
              answer.pos_loc, @position_offset_loc,
            ),
            answer.values.slice(0, 1),
            {},
          )
        )
        throw(1)
      end
      @position_offset = pos2
      @position_offset_loc = p_loc2
      answer.thunks[n2..-1] = []
      catch(8) do
        if limits && @position_offset == offset && !limits[:evaluate_rule_top_stmt]
          if !apply_rule(:evaluate_rule_top_stmt, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
            throw(8)
          end
        else
          if !apply_rule(:evaluate_rule_top_stmt, answer.thunks, answer.values, 1, offset, offset_loc)
            throw(8)
          end
        end
        answer.thunks.push(
          ThunkLeaf.new(
            :action_top_stmts_1,
            Capture.new(
              answer.pos, @position_offset,
              answer.pos_loc, @position_offset_loc,
            ),
            answer.values.slice(1),
            {},
          )
        )
        throw(1)
      end
      @position_offset = pos2
      @position_offset_loc = p_loc2
      answer.thunks[n2..-1] = []
      catch(9) do
        pos4 = @position_offset
        p_loc4 = @position_offset_loc
        n4 = answer.thunks.length
        catch(11) do
          catch(10) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
              if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(10)
              end
            else
              if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
                throw(10)
              end
            end
            throw(11)
          end
          @position_offset_loc = p_loc4
          @position_offset = pos4
          answer.thunks[n4..-1] = []
        end
        answer.thunks.push(
          ThunkLeaf.new(
            :action_top_stmts_2,
            Capture.new(
              answer.pos, @position_offset,
              answer.pos_loc, @position_offset_loc,
            ),
            {},
            {},
          )
        )
      end
    end
    @level -= 1
    debug { warn "#{ "  " * @level}MATCH   top_stmts #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return answer
  end

  def evaluate_rule_top_stmt(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    top_stmt #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if limits && @position_offset == offset && !limits[:evaluate_rule_stmt]
        if !apply_rule(:evaluate_rule_stmt, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_stmt, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_top_stmt_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0),
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   top_stmt #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH top_stmt #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_stmt(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    stmt #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if limits && @position_offset == offset && !limits[:evaluate_rule_expr]
        if !apply_rule(:evaluate_rule_expr, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_expr, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_stmt_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0),
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   stmt #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH stmt #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_compstmt(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    compstmt #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if limits && @position_offset == offset && !limits[:evaluate_rule_stmts]
        if !apply_rule(:evaluate_rule_stmts, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_stmts, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_compstmt_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0),
          {},
        )
      )
      i3 = 0
      pos3 = nil
      p_loc3 = nil
      n3 = nil
      catch(1) do
        pos3 = @position_offset
        p_loc3 = @position_offset_loc
        n3 = answer.thunks.length
        if limits && @position_offset == offset && !limits[:evaluate_rule_term]
          if !apply_rule(:evaluate_rule_term, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
            throw(1)
          end
        else
          if !apply_rule(:evaluate_rule_term, answer.thunks, nil, 0, offset, offset_loc)
            throw(1)
          end
        end
        i3 += 1
        if @position_offset != pos3
          redo
        end
        pos3 = nil
      end
      if pos3
        @position_offset = pos3
        @position_offset_loc = p_loc3
        answer.thunks[n3..-1] = []
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   compstmt #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH compstmt #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_bodystmt(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    bodystmt #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if limits && @position_offset == offset && !limits[:evaluate_rule_compstmt]
        if !apply_rule(:evaluate_rule_compstmt, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_compstmt, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_bodystmt_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0),
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   bodystmt #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH bodystmt #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_stmts(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    stmts #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      catch(1) do
        pos2 = @position_offset
        p_loc2 = @position_offset_loc
        n2 = answer.thunks.length
        catch(2) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_stmts]
            if !apply_rule(:evaluate_rule_stmts, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
              throw(2)
            end
          else
            if !apply_rule(:evaluate_rule_stmts, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(2)
            end
          end
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          n4 = answer.thunks.length
          catch(4) do
            catch(3) do
              if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                  throw(3)
                end
              else
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
                  throw(3)
                end
              end
              throw(4)
            end
            @position_offset_loc = p_loc4
            @position_offset = pos4
            answer.thunks[n4..-1] = []
          end
          q4 = @position_offset
          q_loc4 = @position_offset_loc
          m4 = answer.thunks.length
          i4 = 0
          pos4 = nil
          p_loc4 = nil
          n4 = nil
          catch(5) do
            pos4 = @position_offset
            p_loc4 = @position_offset_loc
            n4 = answer.thunks.length
            if limits && @position_offset == offset && !limits[:evaluate_rule_term]
              if !apply_rule(:evaluate_rule_term, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(5)
              end
            else
              if !apply_rule(:evaluate_rule_term, answer.thunks, nil, 0, offset, offset_loc)
                throw(5)
              end
            end
            i4 += 1
            if @position_offset != pos4
              redo
            end
            pos4 = nil
          end
          if pos4
            @position_offset = pos4
            @position_offset_loc = p_loc4
            answer.thunks[n4..-1] = []
          end
          if i4 < 1
            @position_offset = q4
            @position_offset_loc = q_loc4
            answer.thunks[m4..-1] = []
            throw(2)
          end
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          n4 = answer.thunks.length
          catch(7) do
            catch(6) do
              if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                  throw(6)
                end
              else
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
                  throw(6)
                end
              end
              throw(7)
            end
            @position_offset_loc = p_loc4
            @position_offset = pos4
            answer.thunks[n4..-1] = []
          end
          if limits && @position_offset == offset && !limits[:evaluate_rule_stmt]
            if !apply_rule(:evaluate_rule_stmt, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
              throw(2)
            end
          else
            if !apply_rule(:evaluate_rule_stmt, answer.thunks, answer.values, 1, offset, offset_loc)
              throw(2)
            end
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_stmts_0,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(0, 1),
              {},
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(8) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_stmt]
            if !apply_rule(:evaluate_rule_stmt, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
              throw(8)
            end
          else
            if !apply_rule(:evaluate_rule_stmt, answer.thunks, answer.values, 1, offset, offset_loc)
              throw(8)
            end
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_stmts_1,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(1),
              {},
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   stmts #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH stmts #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_expr(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    expr #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      catch(1) do
        pos2 = @position_offset
        p_loc2 = @position_offset_loc
        n2 = answer.thunks.length
        catch(2) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_command_call]
            if !apply_rule(:evaluate_rule_command_call, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
              throw(2)
            end
          else
            if !apply_rule(:evaluate_rule_command_call, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(2)
            end
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_expr_0,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(3) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_arg]
            if !apply_rule(:evaluate_rule_arg, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
              throw(3)
            end
          else
            if !apply_rule(:evaluate_rule_arg, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(3)
            end
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_expr_1,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   expr #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH expr #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_command_call(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    command_call #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if limits && @position_offset == offset && !limits[:evaluate_rule_command]
        if !apply_rule(:evaluate_rule_command, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_command, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_command_call_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0),
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   command_call #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH command_call #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_command(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    command #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if limits && @position_offset == offset && !limits[:evaluate_rule_fcall]
        if !apply_rule(:evaluate_rule_fcall, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_fcall, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
        if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
          throw(0)
        end
      end
      if limits && @position_offset == offset && !limits[:evaluate_rule_command_args]
        if !apply_rule(:evaluate_rule_command_args, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_command_args, answer.thunks, answer.values, 1, offset, offset_loc)
          throw(0)
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_command_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0, 1),
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   command #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH command #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_method_call(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    method_call #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(1)
    answer.values = {}
    catch(0) do
      catch(1) do
        pos2 = @position_offset
        p_loc2 = @position_offset_loc
        n2 = answer.thunks.length
        catch(2) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_fcall]
            if !apply_rule(:evaluate_rule_fcall, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
              throw(2)
            end
          else
            if !apply_rule(:evaluate_rule_fcall, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(2)
            end
          end
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          n4 = answer.thunks.length
          catch(4) do
            catch(3) do
              if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                  throw(3)
                end
              else
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
                  throw(3)
                end
              end
              throw(4)
            end
            @position_offset_loc = p_loc4
            @position_offset = pos4
            answer.thunks[n4..-1] = []
          end
          if limits && @position_offset == offset && !limits[:evaluate_rule_paren_args]
            if !apply_rule(:evaluate_rule_paren_args, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
              throw(2)
            end
          else
            if !apply_rule(:evaluate_rule_paren_args, answer.thunks, answer.values, 1, offset, offset_loc)
              throw(2)
            end
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_method_call_0,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(0, 1),
              {},
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(5) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_primary]
            if !apply_rule(:evaluate_rule_primary, answer.thunks, answer.values, 2, offset, offset_loc, limits: limits)
              throw(5)
            end
          else
            if !apply_rule(:evaluate_rule_primary, answer.thunks, answer.values, 2, offset, offset_loc)
              throw(5)
            end
          end
          if limits && @position_offset == offset && !limits[:evaluate_rule_call_op]
            if !apply_rule(:evaluate_rule_call_op, answer.thunks, answer.values, 3, offset, offset_loc, limits: limits)
              throw(5)
            end
          else
            if !apply_rule(:evaluate_rule_call_op, answer.thunks, answer.values, 3, offset, offset_loc)
              throw(5)
            end
          end
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          if limits && @position_offset == offset && !limits[:evaluate_rule_operation2]
            if !apply_rule(:evaluate_rule_operation2, answer.thunks, answer.values, 4, offset, offset_loc, limits: limits)
              throw(5)
            end
          else
            if !apply_rule(:evaluate_rule_operation2, answer.thunks, answer.values, 4, offset, offset_loc)
              throw(5)
            end
          end
          q4 = @position_offset
          capt4 = answer.capts[0]
          capt4.range_start = pos4
          capt4.range_end = q4
          q_loc4 = @position_offset_loc
          capt4.start_loc = p_loc4
          capt4.end_loc = q_loc4
          catch(6) do
            pos4 = @position_offset
            p_loc4 = @position_offset_loc
            n4 = answer.thunks.length
            catch(7) do
              if limits && @position_offset == offset && !limits[:evaluate_rule_paren_args]
                if !apply_rule(:evaluate_rule_paren_args, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
                  throw(7)
                end
              else
                if !apply_rule(:evaluate_rule_paren_args, answer.thunks, answer.values, 1, offset, offset_loc)
                  throw(7)
                end
              end
              answer.thunks.push(
                ThunkLeaf.new(
                  :action_method_call_1,
                  Capture.new(
                    answer.pos, @position_offset,
                    answer.pos_loc, @position_offset_loc,
                  ),
                  answer.values.slice(2, 3, 4, 1),
                  answer.capts.slice(0),
                )
              )
              throw(6)
            end
            @position_offset = pos4
            @position_offset_loc = p_loc4
            answer.thunks[n4..-1] = []
            catch(8) do
              answer.thunks.push(
                ThunkLeaf.new(
                  :action_method_call_2,
                  Capture.new(
                    answer.pos, @position_offset,
                    answer.pos_loc, @position_offset_loc,
                  ),
                  answer.values.slice(2, 3, 4),
                  answer.capts.slice(0),
                )
              )
            end
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_method_call_3,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(2, 3, 4),
              answer.capts.slice(0),
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   method_call #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH method_call #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_fcall(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    fcall #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if limits && @position_offset == offset && !limits[:evaluate_rule_operation]
        if !apply_rule(:evaluate_rule_operation, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_operation, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_fcall_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0),
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   fcall #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH fcall #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_fname(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    fname #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      catch(1) do
        pos2 = @position_offset
        p_loc2 = @position_offset_loc
        n2 = answer.thunks.length
        catch(2) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_tIDENTIFIER]
            if !apply_rule(:evaluate_rule_tIDENTIFIER, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
              throw(2)
            end
          else
            if !apply_rule(:evaluate_rule_tIDENTIFIER, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(2)
            end
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_fname_0,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(3) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_tCONSTANT]
            if !apply_rule(:evaluate_rule_tCONSTANT, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
              throw(3)
            end
          else
            if !apply_rule(:evaluate_rule_tCONSTANT, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(3)
            end
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_fname_1,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(4) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_op]
            if !apply_rule(:evaluate_rule_op, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
              throw(4)
            end
          else
            if !apply_rule(:evaluate_rule_op, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(4)
            end
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_fname_2,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   fname #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH fname #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_operation(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    operation #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if limits && @position_offset == offset && !limits[:evaluate_rule_tIDENTIFIER]
        if !apply_rule(:evaluate_rule_tIDENTIFIER, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_tIDENTIFIER, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_operation_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0),
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   operation #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH operation #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_operation2(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    operation2 #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      catch(1) do
        pos2 = @position_offset
        p_loc2 = @position_offset_loc
        n2 = answer.thunks.length
        catch(2) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_operation]
            if !apply_rule(:evaluate_rule_operation, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
              throw(2)
            end
          else
            if !apply_rule(:evaluate_rule_operation, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(2)
            end
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_operation2_0,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(3) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_op]
            if !apply_rule(:evaluate_rule_op, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
              throw(3)
            end
          else
            if !apply_rule(:evaluate_rule_op, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(3)
            end
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_operation2_1,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   operation2 #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH operation2 #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_op(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    op #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      if refill_buffer(1) < 1
        throw(0)
      end
      u3 = @buffer[@position_offset]
      if (!(
        u3 == "-" ||
        u3 == "+" ||
        u3 == "/" ||
        u3 == "%" ||
        u3 == "*"
      ))
        throw(0)
      end
      @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
      @position_offset += 1
      answer.thunks.push(
        ThunkLeaf.new(
          :action_op_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          {},
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   op #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH op #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_call_op(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    call_op #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      catch(1) do
        pos2 = @position_offset
        p_loc2 = @position_offset_loc
        n2 = answer.thunks.length
        catch(2) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@position_offset] != "."
          )
            throw(2)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
          @position_offset += 1
          answer.thunks.push(
            ThunkLeaf.new(
              :action_call_op_0,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              {},
              {},
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(3) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_tANDDOT]
            if !apply_rule(:evaluate_rule_tANDDOT, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
              throw(3)
            end
          else
            if !apply_rule(:evaluate_rule_tANDDOT, answer.thunks, nil, 0, offset, offset_loc)
              throw(3)
            end
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_call_op_1,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              {},
              {},
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   call_op #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH call_op #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_tANDDOT(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    tANDDOT #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      if (
        refill_buffer(2) < 2 ||
        @buffer[@position_offset, 2] != "&."
      )
        throw(0)
      end
      @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 2)
      @position_offset += 2
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   tANDDOT #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH tANDDOT #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_command_args(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    command_args #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if limits && @position_offset == offset && !limits[:evaluate_rule_call_args]
        if !apply_rule(:evaluate_rule_call_args, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_call_args, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_command_args_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0),
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   command_args #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH command_args #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_paren_args(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    paren_args #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if (
        refill_buffer(1) < 1 ||
        @buffer[@position_offset] != "("
      )
        throw(0)
      end
      @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
      @position_offset += 1
      pos3 = @position_offset
      p_loc3 = @position_offset_loc
      n3 = answer.thunks.length
      catch(2) do
        catch(1) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
            if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
              throw(1)
            end
          else
            if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
              throw(1)
            end
          end
          throw(2)
        end
        @position_offset_loc = p_loc3
        @position_offset = pos3
        answer.thunks[n3..-1] = []
      end
      pos3 = @position_offset
      p_loc3 = @position_offset_loc
      n3 = answer.thunks.length
      catch(4) do
        catch(3) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_call_args]
            if !apply_rule(:evaluate_rule_call_args, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
              throw(3)
            end
          else
            if !apply_rule(:evaluate_rule_call_args, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(3)
            end
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_paren_args_0,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(4)
        end
        @position_offset_loc = p_loc3
        @position_offset = pos3
        answer.thunks[n3..-1] = []
      end
      pos3 = @position_offset
      p_loc3 = @position_offset_loc
      n3 = answer.thunks.length
      catch(6) do
        catch(5) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
            if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
              throw(5)
            end
          else
            if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
              throw(5)
            end
          end
          throw(6)
        end
        @position_offset_loc = p_loc3
        @position_offset = pos3
        answer.thunks[n3..-1] = []
      end
      if (
        refill_buffer(1) < 1 ||
        @buffer[@position_offset] != ")"
      )
        throw(0)
      end
      @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
      @position_offset += 1
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   paren_args #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH paren_args #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_call_args(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    call_args #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if limits && @position_offset == offset && !limits[:evaluate_rule_args]
        if !apply_rule(:evaluate_rule_args, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_args, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_call_args_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0),
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   call_args #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH call_args #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_args(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    args #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      catch(1) do
        pos2 = @position_offset
        p_loc2 = @position_offset_loc
        n2 = answer.thunks.length
        catch(2) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_args]
            if !apply_rule(:evaluate_rule_args, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
              throw(2)
            end
          else
            if !apply_rule(:evaluate_rule_args, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(2)
            end
          end
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          n4 = answer.thunks.length
          catch(4) do
            catch(3) do
              if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                  throw(3)
                end
              else
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
                  throw(3)
                end
              end
              throw(4)
            end
            @position_offset_loc = p_loc4
            @position_offset = pos4
            answer.thunks[n4..-1] = []
          end
          if (
            refill_buffer(1) < 1 ||
            @buffer[@position_offset] != ","
          )
            throw(2)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
          @position_offset += 1
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          n4 = answer.thunks.length
          catch(6) do
            catch(5) do
              if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                  throw(5)
                end
              else
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
                  throw(5)
                end
              end
              throw(6)
            end
            @position_offset_loc = p_loc4
            @position_offset = pos4
            answer.thunks[n4..-1] = []
          end
          if limits && @position_offset == offset && !limits[:evaluate_rule_arg_value]
            if !apply_rule(:evaluate_rule_arg_value, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
              throw(2)
            end
          else
            if !apply_rule(:evaluate_rule_arg_value, answer.thunks, answer.values, 1, offset, offset_loc)
              throw(2)
            end
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_args_0,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(0, 1),
              {},
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(7) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_arg_value]
            if !apply_rule(:evaluate_rule_arg_value, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
              throw(7)
            end
          else
            if !apply_rule(:evaluate_rule_arg_value, answer.thunks, answer.values, 1, offset, offset_loc)
              throw(7)
            end
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_args_1,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(1),
              {},
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   args #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH args #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_arg_value(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    arg_value #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if limits && @position_offset == offset && !limits[:evaluate_rule_arg]
        if !apply_rule(:evaluate_rule_arg, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_arg, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_arg_value_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0),
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   arg_value #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH arg_value #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_arg_rhs(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    arg_rhs #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if limits && @position_offset == offset && !limits[:evaluate_rule_arg]
        if !apply_rule(:evaluate_rule_arg, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_arg, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_arg_rhs_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0),
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   arg_rhs #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH arg_rhs #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_arg(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    arg #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      catch(1) do
        pos2 = @position_offset
        p_loc2 = @position_offset_loc
        n2 = answer.thunks.length
        catch(2) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_arg_addsub]
            if !apply_rule(:evaluate_rule_arg_addsub, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
              throw(2)
            end
          else
            if !apply_rule(:evaluate_rule_arg_addsub, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(2)
            end
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_arg_0,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(3) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_tIDENTIFIER]
            if !apply_rule(:evaluate_rule_tIDENTIFIER, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
              throw(3)
            end
          else
            if !apply_rule(:evaluate_rule_tIDENTIFIER, answer.thunks, answer.values, 1, offset, offset_loc)
              throw(3)
            end
          end
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          n4 = answer.thunks.length
          catch(5) do
            catch(4) do
              if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                  throw(4)
                end
              else
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
                  throw(4)
                end
              end
              throw(5)
            end
            @position_offset_loc = p_loc4
            @position_offset = pos4
            answer.thunks[n4..-1] = []
          end
          if (
            refill_buffer(1) < 1 ||
            @buffer[@position_offset] != "="
          )
            throw(3)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
          @position_offset += 1
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          n4 = answer.thunks.length
          catch(7) do
            catch(6) do
              if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                  throw(6)
                end
              else
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
                  throw(6)
                end
              end
              throw(7)
            end
            @position_offset_loc = p_loc4
            @position_offset = pos4
            answer.thunks[n4..-1] = []
          end
          if limits && @position_offset == offset && !limits[:evaluate_rule_arg_rhs]
            if !apply_rule(:evaluate_rule_arg_rhs, answer.thunks, answer.values, 2, offset, offset_loc, limits: limits)
              throw(3)
            end
          else
            if !apply_rule(:evaluate_rule_arg_rhs, answer.thunks, answer.values, 2, offset, offset_loc)
              throw(3)
            end
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_arg_1,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(1, 2),
              {},
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   arg #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH arg #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_arg_addsub(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    arg_addsub #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(1)
    answer.values = {}
    catch(0) do
      catch(1) do
        pos2 = @position_offset
        p_loc2 = @position_offset_loc
        n2 = answer.thunks.length
        catch(2) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_arg_addsub]
            if !apply_rule(:evaluate_rule_arg_addsub, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
              throw(2)
            end
          else
            if !apply_rule(:evaluate_rule_arg_addsub, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(2)
            end
          end
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          n4 = answer.thunks.length
          catch(4) do
            catch(3) do
              if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                  throw(3)
                end
              else
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
                  throw(3)
                end
              end
              throw(4)
            end
            @position_offset_loc = p_loc4
            @position_offset = pos4
            answer.thunks[n4..-1] = []
          end
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          if refill_buffer(1) < 1
            throw(2)
          end
          u5 = @buffer[@position_offset]
          if (!(
            u5 == "-" ||
            u5 == "+"
          ))
            throw(2)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
          @position_offset += 1
          q4 = @position_offset
          capt4 = answer.capts[0]
          capt4.range_start = pos4
          capt4.range_end = q4
          q_loc4 = @position_offset_loc
          capt4.start_loc = p_loc4
          capt4.end_loc = q_loc4
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          n4 = answer.thunks.length
          catch(6) do
            catch(5) do
              if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                  throw(5)
                end
              else
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
                  throw(5)
                end
              end
              throw(6)
            end
            @position_offset_loc = p_loc4
            @position_offset = pos4
            answer.thunks[n4..-1] = []
          end
          if limits && @position_offset == offset && !limits[:evaluate_rule_arg_muldiv]
            if !apply_rule(:evaluate_rule_arg_muldiv, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
              throw(2)
            end
          else
            if !apply_rule(:evaluate_rule_arg_muldiv, answer.thunks, answer.values, 1, offset, offset_loc)
              throw(2)
            end
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_arg_addsub_0,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(0, 1),
              answer.capts.slice(0),
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(7) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_arg_muldiv]
            if !apply_rule(:evaluate_rule_arg_muldiv, answer.thunks, answer.values, 2, offset, offset_loc, limits: limits)
              throw(7)
            end
          else
            if !apply_rule(:evaluate_rule_arg_muldiv, answer.thunks, answer.values, 2, offset, offset_loc)
              throw(7)
            end
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_arg_addsub_1,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(2),
              {},
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   arg_addsub #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH arg_addsub #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_arg_muldiv(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    arg_muldiv #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(1)
    answer.values = {}
    catch(0) do
      catch(1) do
        pos2 = @position_offset
        p_loc2 = @position_offset_loc
        n2 = answer.thunks.length
        catch(2) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_arg_muldiv]
            if !apply_rule(:evaluate_rule_arg_muldiv, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
              throw(2)
            end
          else
            if !apply_rule(:evaluate_rule_arg_muldiv, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(2)
            end
          end
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          n4 = answer.thunks.length
          catch(4) do
            catch(3) do
              if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                  throw(3)
                end
              else
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
                  throw(3)
                end
              end
              throw(4)
            end
            @position_offset_loc = p_loc4
            @position_offset = pos4
            answer.thunks[n4..-1] = []
          end
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          if refill_buffer(1) < 1
            throw(2)
          end
          u5 = @buffer[@position_offset]
          if (!(
            u5 == "*" ||
            u5 == "/" ||
            u5 == "%"
          ))
            throw(2)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
          @position_offset += 1
          q4 = @position_offset
          capt4 = answer.capts[0]
          capt4.range_start = pos4
          capt4.range_end = q4
          q_loc4 = @position_offset_loc
          capt4.start_loc = p_loc4
          capt4.end_loc = q_loc4
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          n4 = answer.thunks.length
          catch(6) do
            catch(5) do
              if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                  throw(5)
                end
              else
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
                  throw(5)
                end
              end
              throw(6)
            end
            @position_offset_loc = p_loc4
            @position_offset = pos4
            answer.thunks[n4..-1] = []
          end
          if limits && @position_offset == offset && !limits[:evaluate_rule_arg_primary]
            if !apply_rule(:evaluate_rule_arg_primary, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
              throw(2)
            end
          else
            if !apply_rule(:evaluate_rule_arg_primary, answer.thunks, answer.values, 1, offset, offset_loc)
              throw(2)
            end
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_arg_muldiv_0,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(0, 1),
              answer.capts.slice(0),
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(7) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_arg_primary]
            if !apply_rule(:evaluate_rule_arg_primary, answer.thunks, answer.values, 2, offset, offset_loc, limits: limits)
              throw(7)
            end
          else
            if !apply_rule(:evaluate_rule_arg_primary, answer.thunks, answer.values, 2, offset, offset_loc)
              throw(7)
            end
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_arg_muldiv_1,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(2),
              {},
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   arg_muldiv #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH arg_muldiv #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_arg_primary(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    arg_primary #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if limits && @position_offset == offset && !limits[:evaluate_rule_primary]
        if !apply_rule(:evaluate_rule_primary, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_primary, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_arg_primary_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0),
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   arg_primary #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH arg_primary #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_primary(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    primary #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(2)
    answer.values = {}
    catch(0) do
      catch(1) do
        pos2 = @position_offset
        p_loc2 = @position_offset_loc
        n2 = answer.thunks.length
        catch(2) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_defn_head]
            if !apply_rule(:evaluate_rule_defn_head, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
              throw(2)
            end
          else
            if !apply_rule(:evaluate_rule_defn_head, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(2)
            end
          end
          if limits && @position_offset == offset && !limits[:evaluate_rule_f_arglist]
            if !apply_rule(:evaluate_rule_f_arglist, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
              throw(2)
            end
          else
            if !apply_rule(:evaluate_rule_f_arglist, answer.thunks, answer.values, 1, offset, offset_loc)
              throw(2)
            end
          end
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          n4 = answer.thunks.length
          catch(4) do
            catch(3) do
              if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                  throw(3)
                end
              else
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
                  throw(3)
                end
              end
              throw(4)
            end
            @position_offset_loc = p_loc4
            @position_offset = pos4
            answer.thunks[n4..-1] = []
          end
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          n4 = answer.thunks.length
          catch(6) do
            catch(5) do
              if limits && @position_offset == offset && !limits[:evaluate_rule_bodystmt]
                if !apply_rule(:evaluate_rule_bodystmt, answer.thunks, answer.values, 2, offset, offset_loc, limits: limits)
                  throw(5)
                end
              else
                if !apply_rule(:evaluate_rule_bodystmt, answer.thunks, answer.values, 2, offset, offset_loc)
                  throw(5)
                end
              end
              throw(6)
            end
            @position_offset_loc = p_loc4
            @position_offset = pos4
            answer.thunks[n4..-1] = []
          end
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          n4 = answer.thunks.length
          catch(8) do
            catch(7) do
              if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                  throw(7)
                end
              else
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
                  throw(7)
                end
              end
              throw(8)
            end
            @position_offset_loc = p_loc4
            @position_offset = pos4
            answer.thunks[n4..-1] = []
          end
          if (
            refill_buffer(3) < 3 ||
            @buffer[@position_offset, 3] != "end"
          )
            throw(2)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 3)
          @position_offset += 3
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_0,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(0, 1, 2),
              {},
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(9) do
          if (
            refill_buffer(5) < 5 ||
            @buffer[@position_offset, 5] != "class"
          )
            throw(9)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 5)
          @position_offset += 5
          if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
            if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
              throw(9)
            end
          else
            if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
              throw(9)
            end
          end
          if limits && @position_offset == offset && !limits[:evaluate_rule_cpath]
            if !apply_rule(:evaluate_rule_cpath, answer.thunks, answer.values, 3, offset, offset_loc, limits: limits)
              throw(9)
            end
          else
            if !apply_rule(:evaluate_rule_cpath, answer.thunks, answer.values, 3, offset, offset_loc)
              throw(9)
            end
          end
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          pos5 = @position_offset
          p_loc5 = @position_offset_loc
          n5 = answer.thunks.length
          catch(11) do
            catch(10) do
              if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                  throw(10)
                end
              else
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
                  throw(10)
                end
              end
              throw(11)
            end
            @position_offset_loc = p_loc5
            @position_offset = pos5
            answer.thunks[n5..-1] = []
          end
          q4 = @position_offset
          capt4 = answer.capts[0]
          capt4.range_start = pos4
          capt4.range_end = q4
          q_loc4 = @position_offset_loc
          capt4.start_loc = p_loc4
          capt4.end_loc = q_loc4
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          pos5 = @position_offset
          p_loc5 = @position_offset_loc
          n5 = answer.thunks.length
          catch(13) do
            catch(12) do
              if limits && @position_offset == offset && !limits[:evaluate_rule_term]
                if !apply_rule(:evaluate_rule_term, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                  throw(12)
                end
              else
                if !apply_rule(:evaluate_rule_term, answer.thunks, nil, 0, offset, offset_loc)
                  throw(12)
                end
              end
              throw(13)
            end
            @position_offset_loc = p_loc5
            @position_offset = pos5
            answer.thunks[n5..-1] = []
          end
          q4 = @position_offset
          capt4 = answer.capts[1]
          capt4.range_start = pos4
          capt4.range_end = q4
          q_loc4 = @position_offset_loc
          capt4.start_loc = p_loc4
          capt4.end_loc = q_loc4
          i4 = 0
          pos4 = nil
          p_loc4 = nil
          n4 = nil
          catch(14) do
            pos4 = @position_offset
            p_loc4 = @position_offset_loc
            n4 = answer.thunks.length
            pos6 = @position_offset
            p_loc6 = @position_offset_loc
            n6 = answer.thunks.length
            catch(16) do
              catch(15) do
                if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
                  if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                    throw(15)
                  end
                else
                  if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
                    throw(15)
                  end
                end
                throw(16)
              end
              @position_offset_loc = p_loc6
              @position_offset = pos6
              answer.thunks[n6..-1] = []
            end
            pos6 = @position_offset
            p_loc6 = @position_offset_loc
            n6 = answer.thunks.length
            catch(18) do
              catch(17) do
                if limits && @position_offset == offset && !limits[:evaluate_rule_term]
                  if !apply_rule(:evaluate_rule_term, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                    throw(17)
                  end
                else
                  if !apply_rule(:evaluate_rule_term, answer.thunks, nil, 0, offset, offset_loc)
                    throw(17)
                  end
                end
                throw(18)
              end
              @position_offset_loc = p_loc6
              @position_offset = pos6
              answer.thunks[n6..-1] = []
            end
            i4 += 1
            if @position_offset != pos4
              redo
            end
            pos4 = nil
          end
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          n4 = answer.thunks.length
          catch(20) do
            catch(19) do
              if limits && @position_offset == offset && !limits[:evaluate_rule_bodystmt]
                if !apply_rule(:evaluate_rule_bodystmt, answer.thunks, answer.values, 2, offset, offset_loc, limits: limits)
                  throw(19)
                end
              else
                if !apply_rule(:evaluate_rule_bodystmt, answer.thunks, answer.values, 2, offset, offset_loc)
                  throw(19)
                end
              end
              throw(20)
            end
            @position_offset_loc = p_loc4
            @position_offset = pos4
            answer.thunks[n4..-1] = []
          end
          i4 = 0
          pos4 = nil
          p_loc4 = nil
          n4 = nil
          catch(21) do
            pos4 = @position_offset
            p_loc4 = @position_offset_loc
            n4 = answer.thunks.length
            pos6 = @position_offset
            p_loc6 = @position_offset_loc
            n6 = answer.thunks.length
            catch(23) do
              catch(22) do
                if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
                  if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                    throw(22)
                  end
                else
                  if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
                    throw(22)
                  end
                end
                throw(23)
              end
              @position_offset_loc = p_loc6
              @position_offset = pos6
              answer.thunks[n6..-1] = []
            end
            pos6 = @position_offset
            p_loc6 = @position_offset_loc
            n6 = answer.thunks.length
            catch(25) do
              catch(24) do
                if limits && @position_offset == offset && !limits[:evaluate_rule_term]
                  if !apply_rule(:evaluate_rule_term, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                    throw(24)
                  end
                else
                  if !apply_rule(:evaluate_rule_term, answer.thunks, nil, 0, offset, offset_loc)
                    throw(24)
                  end
                end
                throw(25)
              end
              @position_offset_loc = p_loc6
              @position_offset = pos6
              answer.thunks[n6..-1] = []
            end
            i4 += 1
            if @position_offset != pos4
              redo
            end
            pos4 = nil
          end
          if (
            refill_buffer(3) < 3 ||
            @buffer[@position_offset, 3] != "end"
          )
            throw(9)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 3)
          @position_offset += 3
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_1,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(3, 2),
              answer.capts.slice(0, 1),
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(26) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_method_call]
            if !apply_rule(:evaluate_rule_method_call, answer.thunks, answer.values, 4, offset, offset_loc, limits: limits)
              throw(26)
            end
          else
            if !apply_rule(:evaluate_rule_method_call, answer.thunks, answer.values, 4, offset, offset_loc)
              throw(26)
            end
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_2,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(4),
              {},
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(27) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_literal]
            if !apply_rule(:evaluate_rule_literal, answer.thunks, answer.values, 4, offset, offset_loc, limits: limits)
              throw(27)
            end
          else
            if !apply_rule(:evaluate_rule_literal, answer.thunks, answer.values, 4, offset, offset_loc)
              throw(27)
            end
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_3,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(4),
              {},
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(28) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_strings]
            if !apply_rule(:evaluate_rule_strings, answer.thunks, answer.values, 4, offset, offset_loc, limits: limits)
              throw(28)
            end
          else
            if !apply_rule(:evaluate_rule_strings, answer.thunks, answer.values, 4, offset, offset_loc)
              throw(28)
            end
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_4,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(4),
              {},
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(29) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@position_offset] != "("
          )
            throw(29)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
          @position_offset += 1
          if limits && @position_offset == offset && !limits[:evaluate_rule_compstmt]
            if !apply_rule(:evaluate_rule_compstmt, answer.thunks, answer.values, 4, offset, offset_loc, limits: limits)
              throw(29)
            end
          else
            if !apply_rule(:evaluate_rule_compstmt, answer.thunks, answer.values, 4, offset, offset_loc)
              throw(29)
            end
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_5,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(4),
              {},
            )
          )
          if (
            refill_buffer(1) < 1 ||
            @buffer[@position_offset] != ")"
          )
            throw(29)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
          @position_offset += 1
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   primary #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH primary #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_defn_head(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    defn_head #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if (
        refill_buffer(3) < 3 ||
        @buffer[@position_offset, 3] != "def"
      )
        throw(0)
      end
      @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 3)
      @position_offset += 3
      if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
        if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
          throw(0)
        end
      end
      if limits && @position_offset == offset && !limits[:evaluate_rule_def_name]
        if !apply_rule(:evaluate_rule_def_name, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_def_name, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_defn_head_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0),
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   defn_head #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH defn_head #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_def_name(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    def_name #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if limits && @position_offset == offset && !limits[:evaluate_rule_fname]
        if !apply_rule(:evaluate_rule_fname, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_fname, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_def_name_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0),
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   def_name #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH def_name #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_f_arglist(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    f_arglist #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(4)
    answer.values = {}
    catch(0) do
      catch(1) do
        pos2 = @position_offset
        p_loc2 = @position_offset_loc
        n2 = answer.thunks.length
        catch(2) do
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          n4 = answer.thunks.length
          catch(4) do
            catch(3) do
              if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                  throw(3)
                end
              else
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
                  throw(3)
                end
              end
              throw(4)
            end
            @position_offset_loc = p_loc4
            @position_offset = pos4
            answer.thunks[n4..-1] = []
          end
          if limits && @position_offset == offset && !limits[:evaluate_rule_f_paren_args]
            if !apply_rule(:evaluate_rule_f_paren_args, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
              throw(2)
            end
          else
            if !apply_rule(:evaluate_rule_f_paren_args, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(2)
            end
          end
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          pos5 = @position_offset
          p_loc5 = @position_offset_loc
          n5 = answer.thunks.length
          catch(6) do
            catch(5) do
              if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                  throw(5)
                end
              else
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
                  throw(5)
                end
              end
              throw(6)
            end
            @position_offset_loc = p_loc5
            @position_offset = pos5
            answer.thunks[n5..-1] = []
          end
          q4 = @position_offset
          capt4 = answer.capts[0]
          capt4.range_start = pos4
          capt4.range_end = q4
          q_loc4 = @position_offset_loc
          capt4.start_loc = p_loc4
          capt4.end_loc = q_loc4
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          pos5 = @position_offset
          p_loc5 = @position_offset_loc
          n5 = answer.thunks.length
          catch(8) do
            catch(7) do
              if limits && @position_offset == offset && !limits[:evaluate_rule_term]
                if !apply_rule(:evaluate_rule_term, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                  throw(7)
                end
              else
                if !apply_rule(:evaluate_rule_term, answer.thunks, nil, 0, offset, offset_loc)
                  throw(7)
                end
              end
              throw(8)
            end
            @position_offset_loc = p_loc5
            @position_offset = pos5
            answer.thunks[n5..-1] = []
          end
          q4 = @position_offset
          capt4 = answer.capts[1]
          capt4.range_start = pos4
          capt4.range_end = q4
          q_loc4 = @position_offset_loc
          capt4.start_loc = p_loc4
          capt4.end_loc = q_loc4
          i4 = 0
          pos4 = nil
          p_loc4 = nil
          n4 = nil
          catch(9) do
            pos4 = @position_offset
            p_loc4 = @position_offset_loc
            n4 = answer.thunks.length
            i6 = 0
            pos6 = nil
            p_loc6 = nil
            n6 = nil
            catch(10) do
              pos6 = @position_offset
              p_loc6 = @position_offset_loc
              n6 = answer.thunks.length
              if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                  throw(10)
                end
              else
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
                  throw(10)
                end
              end
              i6 += 1
              if @position_offset != pos6
                redo
              end
              pos6 = nil
            end
            if pos6
              @position_offset = pos6
              @position_offset_loc = p_loc6
              answer.thunks[n6..-1] = []
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_term]
              if !apply_rule(:evaluate_rule_term, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(9)
              end
            else
              if !apply_rule(:evaluate_rule_term, answer.thunks, nil, 0, offset, offset_loc)
                throw(9)
              end
            end
            i4 += 1
            if @position_offset != pos4
              redo
            end
            pos4 = nil
          end
          if pos4
            @position_offset = pos4
            @position_offset_loc = p_loc4
            answer.thunks[n4..-1] = []
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_f_arglist_0,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(0),
              answer.capts.slice(0, 1),
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(11) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_f_args]
            if !apply_rule(:evaluate_rule_f_args, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
              throw(11)
            end
          else
            if !apply_rule(:evaluate_rule_f_args, answer.thunks, answer.values, 1, offset, offset_loc)
              throw(11)
            end
          end
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          n4 = answer.thunks.length
          catch(13) do
            catch(12) do
              if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                  throw(12)
                end
              else
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
                  throw(12)
                end
              end
              throw(13)
            end
            @position_offset_loc = p_loc4
            @position_offset = pos4
            answer.thunks[n4..-1] = []
          end
          if limits && @position_offset == offset && !limits[:evaluate_rule_term]
            if !apply_rule(:evaluate_rule_term, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
              throw(11)
            end
          else
            if !apply_rule(:evaluate_rule_term, answer.thunks, nil, 0, offset, offset_loc)
              throw(11)
            end
          end
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          pos5 = @position_offset
          p_loc5 = @position_offset_loc
          n5 = answer.thunks.length
          catch(15) do
            catch(14) do
              if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                  throw(14)
                end
              else
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
                  throw(14)
                end
              end
              throw(15)
            end
            @position_offset_loc = p_loc5
            @position_offset = pos5
            answer.thunks[n5..-1] = []
          end
          q4 = @position_offset
          capt4 = answer.capts[2]
          capt4.range_start = pos4
          capt4.range_end = q4
          q_loc4 = @position_offset_loc
          capt4.start_loc = p_loc4
          capt4.end_loc = q_loc4
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          pos5 = @position_offset
          p_loc5 = @position_offset_loc
          n5 = answer.thunks.length
          catch(17) do
            catch(16) do
              if limits && @position_offset == offset && !limits[:evaluate_rule_term]
                if !apply_rule(:evaluate_rule_term, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                  throw(16)
                end
              else
                if !apply_rule(:evaluate_rule_term, answer.thunks, nil, 0, offset, offset_loc)
                  throw(16)
                end
              end
              throw(17)
            end
            @position_offset_loc = p_loc5
            @position_offset = pos5
            answer.thunks[n5..-1] = []
          end
          q4 = @position_offset
          capt4 = answer.capts[3]
          capt4.range_start = pos4
          capt4.range_end = q4
          q_loc4 = @position_offset_loc
          capt4.start_loc = p_loc4
          capt4.end_loc = q_loc4
          i4 = 0
          pos4 = nil
          p_loc4 = nil
          n4 = nil
          catch(18) do
            pos4 = @position_offset
            p_loc4 = @position_offset_loc
            n4 = answer.thunks.length
            i6 = 0
            pos6 = nil
            p_loc6 = nil
            n6 = nil
            catch(19) do
              pos6 = @position_offset
              p_loc6 = @position_offset_loc
              n6 = answer.thunks.length
              if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                  throw(19)
                end
              else
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
                  throw(19)
                end
              end
              i6 += 1
              if @position_offset != pos6
                redo
              end
              pos6 = nil
            end
            if pos6
              @position_offset = pos6
              @position_offset_loc = p_loc6
              answer.thunks[n6..-1] = []
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_term]
              if !apply_rule(:evaluate_rule_term, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(18)
              end
            else
              if !apply_rule(:evaluate_rule_term, answer.thunks, nil, 0, offset, offset_loc)
                throw(18)
              end
            end
            i4 += 1
            if @position_offset != pos4
              redo
            end
            pos4 = nil
          end
          if pos4
            @position_offset = pos4
            @position_offset_loc = p_loc4
            answer.thunks[n4..-1] = []
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_f_arglist_1,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(1),
              answer.capts.slice(2, 3),
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   f_arglist #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH f_arglist #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_f_paren_args(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    f_paren_args #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if (
        refill_buffer(1) < 1 ||
        @buffer[@position_offset] != "("
      )
        throw(0)
      end
      @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
      @position_offset += 1
      pos3 = @position_offset
      p_loc3 = @position_offset_loc
      n3 = answer.thunks.length
      catch(2) do
        catch(1) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
            if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
              throw(1)
            end
          else
            if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
              throw(1)
            end
          end
          throw(2)
        end
        @position_offset_loc = p_loc3
        @position_offset = pos3
        answer.thunks[n3..-1] = []
      end
      if limits && @position_offset == offset && !limits[:evaluate_rule_f_args]
        if !apply_rule(:evaluate_rule_f_args, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_f_args, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_f_paren_args_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0),
          {},
        )
      )
      pos3 = @position_offset
      p_loc3 = @position_offset_loc
      n3 = answer.thunks.length
      catch(4) do
        catch(3) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
            if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
              throw(3)
            end
          else
            if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
              throw(3)
            end
          end
          throw(4)
        end
        @position_offset_loc = p_loc3
        @position_offset = pos3
        answer.thunks[n3..-1] = []
      end
      if (
        refill_buffer(1) < 1 ||
        @buffer[@position_offset] != ")"
      )
        throw(0)
      end
      @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
      @position_offset += 1
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   f_paren_args #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH f_paren_args #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_f_args(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    f_args #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(1) do
      pos2 = @position_offset
      p_loc2 = @position_offset_loc
      n2 = answer.thunks.length
      catch(2) do
        if limits && @position_offset == offset && !limits[:evaluate_rule_f_arg]
          if !apply_rule(:evaluate_rule_f_arg, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
            throw(2)
          end
        else
          if !apply_rule(:evaluate_rule_f_arg, answer.thunks, answer.values, 0, offset, offset_loc)
            throw(2)
          end
        end
        answer.thunks.push(
          ThunkLeaf.new(
            :action_f_args_0,
            Capture.new(
              answer.pos, @position_offset,
              answer.pos_loc, @position_offset_loc,
            ),
            answer.values.slice(0),
            {},
          )
        )
        throw(1)
      end
      @position_offset = pos2
      @position_offset_loc = p_loc2
      answer.thunks[n2..-1] = []
      catch(3) do
        answer.thunks.push(
          ThunkLeaf.new(
            :action_f_args_1,
            Capture.new(
              answer.pos, @position_offset,
              answer.pos_loc, @position_offset_loc,
            ),
            {},
            {},
          )
        )
      end
    end
    @level -= 1
    debug { warn "#{ "  " * @level}MATCH   f_args #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return answer
  end

  def evaluate_rule_f_arg(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    f_arg #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      catch(1) do
        pos2 = @position_offset
        p_loc2 = @position_offset_loc
        n2 = answer.thunks.length
        catch(2) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_f_arg]
            if !apply_rule(:evaluate_rule_f_arg, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
              throw(2)
            end
          else
            if !apply_rule(:evaluate_rule_f_arg, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(2)
            end
          end
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          n4 = answer.thunks.length
          catch(4) do
            catch(3) do
              if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                  throw(3)
                end
              else
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
                  throw(3)
                end
              end
              throw(4)
            end
            @position_offset_loc = p_loc4
            @position_offset = pos4
            answer.thunks[n4..-1] = []
          end
          if (
            refill_buffer(1) < 1 ||
            @buffer[@position_offset] != ","
          )
            throw(2)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
          @position_offset += 1
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          n4 = answer.thunks.length
          catch(6) do
            catch(5) do
              if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                  throw(5)
                end
              else
                if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
                  throw(5)
                end
              end
              throw(6)
            end
            @position_offset_loc = p_loc4
            @position_offset = pos4
            answer.thunks[n4..-1] = []
          end
          if limits && @position_offset == offset && !limits[:evaluate_rule_f_arg_item]
            if !apply_rule(:evaluate_rule_f_arg_item, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
              throw(2)
            end
          else
            if !apply_rule(:evaluate_rule_f_arg_item, answer.thunks, answer.values, 1, offset, offset_loc)
              throw(2)
            end
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_f_arg_0,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(0, 1),
              {},
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(7) do
          if limits && @position_offset == offset && !limits[:evaluate_rule_f_arg_item]
            if !apply_rule(:evaluate_rule_f_arg_item, answer.thunks, answer.values, 2, offset, offset_loc, limits: limits)
              throw(7)
            end
          else
            if !apply_rule(:evaluate_rule_f_arg_item, answer.thunks, answer.values, 2, offset, offset_loc)
              throw(7)
            end
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_f_arg_1,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(2),
              {},
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   f_arg #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH f_arg #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_f_arg_item(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    f_arg_item #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if limits && @position_offset == offset && !limits[:evaluate_rule_f_arg_asgn]
        if !apply_rule(:evaluate_rule_f_arg_asgn, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_f_arg_asgn, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_f_arg_item_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0),
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   f_arg_item #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH f_arg_item #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_f_arg_asgn(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    f_arg_asgn #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if limits && @position_offset == offset && !limits[:evaluate_rule_f_norm_arg]
        if !apply_rule(:evaluate_rule_f_norm_arg, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_f_norm_arg, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_f_arg_asgn_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0),
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   f_arg_asgn #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH f_arg_asgn #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_f_norm_arg(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    f_norm_arg #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if limits && @position_offset == offset && !limits[:evaluate_rule_tIDENTIFIER]
        if !apply_rule(:evaluate_rule_tIDENTIFIER, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_tIDENTIFIER, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_f_norm_arg_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0),
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   f_norm_arg #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH f_norm_arg #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_cpath(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    cpath #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if limits && @position_offset == offset && !limits[:evaluate_rule_tCONSTANT]
        if !apply_rule(:evaluate_rule_tCONSTANT, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_tCONSTANT, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_cpath_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0),
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   cpath #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH cpath #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_literal(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    literal #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if limits && @position_offset == offset && !limits[:evaluate_rule_numeric]
        if !apply_rule(:evaluate_rule_numeric, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_numeric, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_literal_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0),
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   literal #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH literal #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_strings(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    strings #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if limits && @position_offset == offset && !limits[:evaluate_rule_string]
        if !apply_rule(:evaluate_rule_string, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_string, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_strings_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0),
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   strings #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH strings #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_string(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    string #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if limits && @position_offset == offset && !limits[:evaluate_rule_string1]
        if !apply_rule(:evaluate_rule_string1, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_string1, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_string_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0),
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   string #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH string #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_string1(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    string1 #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(1)
    answer.values = {}
    catch(0) do
      catch(1) do
        pos2 = @position_offset
        p_loc2 = @position_offset_loc
        n2 = answer.thunks.length
        catch(2) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@position_offset] != "\'"
          )
            throw(2)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
          @position_offset += 1
          if limits && @position_offset == offset && !limits[:evaluate_rule_sq_str_content]
            if !apply_rule(:evaluate_rule_sq_str_content, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
              throw(2)
            end
          else
            if !apply_rule(:evaluate_rule_sq_str_content, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(2)
            end
          end
          if (
            refill_buffer(1) < 1 ||
            @buffer[@position_offset] != "\'"
          )
            throw(2)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
          @position_offset += 1
          answer.thunks.push(
            ThunkLeaf.new(
              :action_string1_0,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(3) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@position_offset] != "\""
          )
            throw(3)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
          @position_offset += 1
          if limits && @position_offset == offset && !limits[:evaluate_rule_dq_str_content]
            if !apply_rule(:evaluate_rule_dq_str_content, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
              throw(3)
            end
          else
            if !apply_rule(:evaluate_rule_dq_str_content, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(3)
            end
          end
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          pos5 = @position_offset
          p_loc5 = @position_offset_loc
          n5 = answer.thunks.length
          catch(5) do
            catch(4) do
              if (
                refill_buffer(1) < 1 ||
                @buffer[@position_offset] != "#"
              )
                throw(4)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
              @position_offset += 1
              throw(5)
            end
            @position_offset_loc = p_loc5
            @position_offset = pos5
            answer.thunks[n5..-1] = []
          end
          q4 = @position_offset
          capt4 = answer.capts[0]
          capt4.range_start = pos4
          capt4.range_end = q4
          q_loc4 = @position_offset_loc
          capt4.start_loc = p_loc4
          capt4.end_loc = q_loc4
          if (
            refill_buffer(1) < 1 ||
            @buffer[@position_offset] != "\""
          )
            throw(3)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
          @position_offset += 1
          answer.thunks.push(
            ThunkLeaf.new(
              :action_string1_1,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              answer.values.slice(0),
              answer.capts.slice(0),
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   string1 #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH string1 #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_sq_str_content(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    sq_str_content #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(1) do
      pos2 = @position_offset
      p_loc2 = @position_offset_loc
      n2 = answer.thunks.length
      catch(2) do
        if limits && @position_offset == offset && !limits[:evaluate_rule_sq_str_content]
          if !apply_rule(:evaluate_rule_sq_str_content, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
            throw(2)
          end
        else
          if !apply_rule(:evaluate_rule_sq_str_content, answer.thunks, answer.values, 0, offset, offset_loc)
            throw(2)
          end
        end
        if limits && @position_offset == offset && !limits[:evaluate_rule_sq_str_chunk]
          if !apply_rule(:evaluate_rule_sq_str_chunk, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
            throw(2)
          end
        else
          if !apply_rule(:evaluate_rule_sq_str_chunk, answer.thunks, answer.values, 1, offset, offset_loc)
            throw(2)
          end
        end
        answer.thunks.push(
          ThunkLeaf.new(
            :action_sq_str_content_0,
            Capture.new(
              answer.pos, @position_offset,
              answer.pos_loc, @position_offset_loc,
            ),
            answer.values.slice(0, 1),
            {},
          )
        )
        throw(1)
      end
      @position_offset = pos2
      @position_offset_loc = p_loc2
      answer.thunks[n2..-1] = []
      catch(3) do
        if limits && @position_offset == offset && !limits[:evaluate_rule_sq_str_chunk]
          if !apply_rule(:evaluate_rule_sq_str_chunk, answer.thunks, answer.values, 2, offset, offset_loc, limits: limits)
            throw(3)
          end
        else
          if !apply_rule(:evaluate_rule_sq_str_chunk, answer.thunks, answer.values, 2, offset, offset_loc)
            throw(3)
          end
        end
        answer.thunks.push(
          ThunkLeaf.new(
            :action_sq_str_content_1,
            Capture.new(
              answer.pos, @position_offset,
              answer.pos_loc, @position_offset_loc,
            ),
            answer.values.slice(2),
            {},
          )
        )
        throw(1)
      end
      @position_offset = pos2
      @position_offset_loc = p_loc2
      answer.thunks[n2..-1] = []
      catch(4) do
        answer.thunks.push(
          ThunkLeaf.new(
            :action_sq_str_content_2,
            Capture.new(
              answer.pos, @position_offset,
              answer.pos_loc, @position_offset_loc,
            ),
            {},
            {},
          )
        )
      end
    end
    @level -= 1
    debug { warn "#{ "  " * @level}MATCH   sq_str_content #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return answer
  end

  def evaluate_rule_sq_str_chunk(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    sq_str_chunk #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(2)
    catch(0) do
      catch(1) do
        pos2 = @position_offset
        p_loc2 = @position_offset_loc
        n2 = answer.thunks.length
        catch(2) do
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          q5 = @position_offset
          q_loc5 = @position_offset_loc
          m5 = answer.thunks.length
          i5 = 0
          pos5 = nil
          p_loc5 = nil
          n5 = nil
          catch(3) do
            pos5 = @position_offset
            p_loc5 = @position_offset_loc
            n5 = answer.thunks.length
            catch(4) do
              pos6 = @position_offset
              p_loc6 = @position_offset_loc
              n6 = answer.thunks.length
              catch(5) do
                q7 = @position_offset
                q_loc7 = @position_offset_loc
                m7 = answer.thunks.length
                i7 = 0
                pos7 = nil
                p_loc7 = nil
                n7 = nil
                catch(6) do
                  pos7 = @position_offset
                  p_loc7 = @position_offset_loc
                  n7 = answer.thunks.length
                  if refill_buffer(1) < 1
                    throw(6)
                  end
                  u8 = @buffer[@position_offset]
                  if (
                    u8 == "\\" ||
                    u8 == "'"
                  )
                    throw(6)
                  end
                  @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
                  @position_offset += 1
                  i7 += 1
                  if @position_offset != pos7
                    redo
                  end
                  pos7 = nil
                end
                if pos7
                  @position_offset = pos7
                  @position_offset_loc = p_loc7
                  answer.thunks[n7..-1] = []
                end
                if i7 < 1
                  @position_offset = q7
                  @position_offset_loc = q_loc7
                  answer.thunks[m7..-1] = []
                  throw(5)
                end
                throw(4)
              end
              @position_offset = pos6
              @position_offset_loc = p_loc6
              answer.thunks[n6..-1] = []
              catch(7) do
                if (
                  refill_buffer(1) < 1 ||
                  @buffer[@position_offset] != "\\"
                )
                  throw(7)
                end
                @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
                @position_offset += 1
                if refill_buffer(1) < 1
                  throw(7)
                end
                u8 = @buffer[@position_offset]
                if (
                  u8 == "\\" ||
                  u8 == "'"
                )
                  throw(7)
                end
                @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
                @position_offset += 1
                throw(4)
              end
              @position_offset = pos6
              @position_offset_loc = p_loc6
              answer.thunks[n6..-1] = []
              throw(3)
            end
            i5 += 1
            if @position_offset != pos5
              redo
            end
            pos5 = nil
          end
          if pos5
            @position_offset = pos5
            @position_offset_loc = p_loc5
            answer.thunks[n5..-1] = []
          end
          if i5 < 1
            @position_offset = q5
            @position_offset_loc = q_loc5
            answer.thunks[m5..-1] = []
            throw(2)
          end
          q4 = @position_offset
          capt4 = answer.capts[0]
          capt4.range_start = pos4
          capt4.range_end = q4
          q_loc4 = @position_offset_loc
          capt4.start_loc = p_loc4
          capt4.end_loc = q_loc4
          answer.thunks.push(
            ThunkLeaf.new(
              :action_sq_str_chunk_0,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              {},
              answer.capts.slice(0),
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(8) do
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          catch(9) do
            pos5 = @position_offset
            p_loc5 = @position_offset_loc
            n5 = answer.thunks.length
            catch(10) do
              if (
                refill_buffer(2) < 2 ||
                @buffer[@position_offset, 2] != "\\\\"
              )
                throw(10)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 2)
              @position_offset += 2
              throw(9)
            end
            @position_offset = pos5
            @position_offset_loc = p_loc5
            answer.thunks[n5..-1] = []
            catch(11) do
              if (
                refill_buffer(2) < 2 ||
                @buffer[@position_offset, 2] != "\\'"
              )
                throw(11)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 2)
              @position_offset += 2
              throw(9)
            end
            @position_offset = pos5
            @position_offset_loc = p_loc5
            answer.thunks[n5..-1] = []
            throw(8)
          end
          q4 = @position_offset
          capt4 = answer.capts[1]
          capt4.range_start = pos4
          capt4.range_end = q4
          q_loc4 = @position_offset_loc
          capt4.start_loc = p_loc4
          capt4.end_loc = q_loc4
          answer.thunks.push(
            ThunkLeaf.new(
              :action_sq_str_chunk_1,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              {},
              answer.capts.slice(1),
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   sq_str_chunk #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH sq_str_chunk #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_dq_str_content(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    dq_str_content #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(1) do
      pos2 = @position_offset
      p_loc2 = @position_offset_loc
      n2 = answer.thunks.length
      catch(2) do
        if limits && @position_offset == offset && !limits[:evaluate_rule_dq_str_content]
          if !apply_rule(:evaluate_rule_dq_str_content, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
            throw(2)
          end
        else
          if !apply_rule(:evaluate_rule_dq_str_content, answer.thunks, answer.values, 0, offset, offset_loc)
            throw(2)
          end
        end
        if limits && @position_offset == offset && !limits[:evaluate_rule_dq_str_chunk]
          if !apply_rule(:evaluate_rule_dq_str_chunk, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
            throw(2)
          end
        else
          if !apply_rule(:evaluate_rule_dq_str_chunk, answer.thunks, answer.values, 1, offset, offset_loc)
            throw(2)
          end
        end
        answer.thunks.push(
          ThunkLeaf.new(
            :action_dq_str_content_0,
            Capture.new(
              answer.pos, @position_offset,
              answer.pos_loc, @position_offset_loc,
            ),
            answer.values.slice(0, 1),
            {},
          )
        )
        throw(1)
      end
      @position_offset = pos2
      @position_offset_loc = p_loc2
      answer.thunks[n2..-1] = []
      catch(3) do
        if limits && @position_offset == offset && !limits[:evaluate_rule_dq_str_chunk]
          if !apply_rule(:evaluate_rule_dq_str_chunk, answer.thunks, answer.values, 2, offset, offset_loc, limits: limits)
            throw(3)
          end
        else
          if !apply_rule(:evaluate_rule_dq_str_chunk, answer.thunks, answer.values, 2, offset, offset_loc)
            throw(3)
          end
        end
        answer.thunks.push(
          ThunkLeaf.new(
            :action_dq_str_content_1,
            Capture.new(
              answer.pos, @position_offset,
              answer.pos_loc, @position_offset_loc,
            ),
            answer.values.slice(2),
            {},
          )
        )
        throw(1)
      end
      @position_offset = pos2
      @position_offset_loc = p_loc2
      answer.thunks[n2..-1] = []
      catch(4) do
        answer.thunks.push(
          ThunkLeaf.new(
            :action_dq_str_content_2,
            Capture.new(
              answer.pos, @position_offset,
              answer.pos_loc, @position_offset_loc,
            ),
            {},
            {},
          )
        )
      end
    end
    @level -= 1
    debug { warn "#{ "  " * @level}MATCH   dq_str_content #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return answer
  end

  def evaluate_rule_dq_str_chunk(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    dq_str_chunk #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(2)
    catch(0) do
      catch(1) do
        pos2 = @position_offset
        p_loc2 = @position_offset_loc
        n2 = answer.thunks.length
        catch(2) do
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          q5 = @position_offset
          q_loc5 = @position_offset_loc
          m5 = answer.thunks.length
          i5 = 0
          pos5 = nil
          p_loc5 = nil
          n5 = nil
          catch(3) do
            pos5 = @position_offset
            p_loc5 = @position_offset_loc
            n5 = answer.thunks.length
            catch(4) do
              pos6 = @position_offset
              p_loc6 = @position_offset_loc
              n6 = answer.thunks.length
              if refill_buffer(1) >= 1
                u7 = @buffer[@position_offset]
                unless (
                  u7 == "\\" ||
                  u7 == "\"" ||
                  u7 == "#"
                )
                  @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
                  @position_offset += 1
                  throw(4)
                end
              end
              @position_offset = pos6
              @position_offset_loc = p_loc6
              answer.thunks[n6..-1] = []
              catch(5) do
                if (
                  refill_buffer(1) < 1 ||
                  @buffer[@position_offset] != "#"
                )
                  throw(5)
                end
                @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
                @position_offset += 1
                if refill_buffer(1) < 1
                  throw(5)
                end
                u8 = @buffer[@position_offset]
                if (
                  u8 == "\\" ||
                  u8 == "\"" ||
                  u8 == "{"
                )
                  throw(5)
                end
                @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
                @position_offset += 1
                throw(4)
              end
              @position_offset = pos6
              @position_offset_loc = p_loc6
              answer.thunks[n6..-1] = []
              throw(3)
            end
            i5 += 1
            if @position_offset != pos5
              redo
            end
            pos5 = nil
          end
          if pos5
            @position_offset = pos5
            @position_offset_loc = p_loc5
            answer.thunks[n5..-1] = []
          end
          if i5 < 1
            @position_offset = q5
            @position_offset_loc = q_loc5
            answer.thunks[m5..-1] = []
            throw(2)
          end
          q4 = @position_offset
          capt4 = answer.capts[0]
          capt4.range_start = pos4
          capt4.range_end = q4
          q_loc4 = @position_offset_loc
          capt4.start_loc = p_loc4
          capt4.end_loc = q_loc4
          answer.thunks.push(
            ThunkLeaf.new(
              :action_dq_str_chunk_0,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              {},
              answer.capts.slice(0),
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(6) do
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          catch(7) do
            pos5 = @position_offset
            p_loc5 = @position_offset_loc
            n5 = answer.thunks.length
            catch(8) do
              if (
                refill_buffer(2) < 2 ||
                @buffer[@position_offset, 2] != "\\\\"
              )
                throw(8)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 2)
              @position_offset += 2
              throw(7)
            end
            @position_offset = pos5
            @position_offset_loc = p_loc5
            answer.thunks[n5..-1] = []
            catch(9) do
              if (
                refill_buffer(2) < 2 ||
                @buffer[@position_offset, 2] != "\\\""
              )
                throw(9)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 2)
              @position_offset += 2
              throw(7)
            end
            @position_offset = pos5
            @position_offset_loc = p_loc5
            answer.thunks[n5..-1] = []
            throw(6)
          end
          q4 = @position_offset
          capt4 = answer.capts[1]
          capt4.range_start = pos4
          capt4.range_end = q4
          q_loc4 = @position_offset_loc
          capt4.start_loc = p_loc4
          capt4.end_loc = q_loc4
          answer.thunks.push(
            ThunkLeaf.new(
              :action_dq_str_chunk_1,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              {},
              answer.capts.slice(1),
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   dq_str_chunk #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH dq_str_chunk #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_numeric(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    numeric #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if limits && @position_offset == offset && !limits[:evaluate_rule_simple_numeric]
        if !apply_rule(:evaluate_rule_simple_numeric, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_simple_numeric, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_numeric_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0),
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   numeric #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH numeric #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_simple_numeric(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    simple_numeric #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if limits && @position_offset == offset && !limits[:evaluate_rule_tINTEGER]
        if !apply_rule(:evaluate_rule_tINTEGER, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
          throw(0)
        end
      else
        if !apply_rule(:evaluate_rule_tINTEGER, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_simple_numeric_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          answer.values.slice(0),
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   simple_numeric #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH simple_numeric #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_tINTEGER(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    tINTEGER #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(4)
    catch(0) do
      catch(1) do
        pos2 = @position_offset
        p_loc2 = @position_offset_loc
        n2 = answer.thunks.length
        catch(2) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@position_offset] != "0"
          )
            throw(2)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
          @position_offset += 1
          if refill_buffer(1) < 1
            throw(2)
          end
          u4 = @buffer[@position_offset]
          if (!(
            u4 == "X" ||
            u4 == "x"
          ))
            throw(2)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
          @position_offset += 1
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          q6 = @position_offset
          q_loc6 = @position_offset_loc
          m6 = answer.thunks.length
          i6 = 0
          pos6 = nil
          p_loc6 = nil
          n6 = nil
          catch(3) do
            pos6 = @position_offset
            p_loc6 = @position_offset_loc
            n6 = answer.thunks.length
            if refill_buffer(1) < 1
              throw(3)
            end
            u7 = @buffer[@position_offset]
            if (!(
              (u7 >= "0" && u7 <= "9") ||
              (u7 >= "a" && u7 <= "f") ||
              (u7 >= "A" && u7 <= "F")
            ))
              throw(3)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
            @position_offset += 1
            i6 += 1
            if @position_offset != pos6
              redo
            end
            pos6 = nil
          end
          if pos6
            @position_offset = pos6
            @position_offset_loc = p_loc6
            answer.thunks[n6..-1] = []
          end
          if i6 < 1
            @position_offset = q6
            @position_offset_loc = q_loc6
            answer.thunks[m6..-1] = []
            throw(2)
          end
          i6 = 0
          pos6 = nil
          p_loc6 = nil
          n6 = nil
          catch(4) do
            pos6 = @position_offset
            p_loc6 = @position_offset_loc
            n6 = answer.thunks.length
            q8 = @position_offset
            q_loc8 = @position_offset_loc
            m8 = answer.thunks.length
            i8 = 0
            pos8 = nil
            p_loc8 = nil
            n8 = nil
            catch(5) do
              pos8 = @position_offset
              p_loc8 = @position_offset_loc
              n8 = answer.thunks.length
              if (
                refill_buffer(1) < 1 ||
                @buffer[@position_offset] != "_"
              )
                throw(5)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
              @position_offset += 1
              i8 += 1
              if @position_offset != pos8
                redo
              end
              pos8 = nil
            end
            if pos8
              @position_offset = pos8
              @position_offset_loc = p_loc8
              answer.thunks[n8..-1] = []
            end
            if i8 < 1
              @position_offset = q8
              @position_offset_loc = q_loc8
              answer.thunks[m8..-1] = []
              throw(4)
            end
            q8 = @position_offset
            q_loc8 = @position_offset_loc
            m8 = answer.thunks.length
            i8 = 0
            pos8 = nil
            p_loc8 = nil
            n8 = nil
            catch(6) do
              pos8 = @position_offset
              p_loc8 = @position_offset_loc
              n8 = answer.thunks.length
              if refill_buffer(1) < 1
                throw(6)
              end
              u9 = @buffer[@position_offset]
              if (!(
                (u9 >= "0" && u9 <= "9") ||
                (u9 >= "a" && u9 <= "f") ||
                (u9 >= "A" && u9 <= "F")
              ))
                throw(6)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
              @position_offset += 1
              i8 += 1
              if @position_offset != pos8
                redo
              end
              pos8 = nil
            end
            if pos8
              @position_offset = pos8
              @position_offset_loc = p_loc8
              answer.thunks[n8..-1] = []
            end
            if i8 < 1
              @position_offset = q8
              @position_offset_loc = q_loc8
              answer.thunks[m8..-1] = []
              throw(4)
            end
            i6 += 1
            if @position_offset != pos6
              redo
            end
            pos6 = nil
          end
          if pos6
            @position_offset = pos6
            @position_offset_loc = p_loc6
            answer.thunks[n6..-1] = []
          end
          q4 = @position_offset
          capt4 = answer.capts[0]
          capt4.range_start = pos4
          capt4.range_end = q4
          q_loc4 = @position_offset_loc
          capt4.start_loc = p_loc4
          capt4.end_loc = q_loc4
          answer.thunks.push(
            ThunkLeaf.new(
              :action_tINTEGER_0,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              {},
              answer.capts.slice(0),
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(7) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@position_offset] != "0"
          )
            throw(7)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
          @position_offset += 1
          if refill_buffer(1) < 1
            throw(7)
          end
          u4 = @buffer[@position_offset]
          if (!(
            u4 == "O" ||
            u4 == "o"
          ))
            throw(7)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
          @position_offset += 1
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          q6 = @position_offset
          q_loc6 = @position_offset_loc
          m6 = answer.thunks.length
          i6 = 0
          pos6 = nil
          p_loc6 = nil
          n6 = nil
          catch(8) do
            pos6 = @position_offset
            p_loc6 = @position_offset_loc
            n6 = answer.thunks.length
            if refill_buffer(1) < 1
              throw(8)
            end
            u7 = @buffer[@position_offset]
            if (!(
              (u7 >= "0" && u7 <= "7")
            ))
              throw(8)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
            @position_offset += 1
            i6 += 1
            if @position_offset != pos6
              redo
            end
            pos6 = nil
          end
          if pos6
            @position_offset = pos6
            @position_offset_loc = p_loc6
            answer.thunks[n6..-1] = []
          end
          if i6 < 1
            @position_offset = q6
            @position_offset_loc = q_loc6
            answer.thunks[m6..-1] = []
            throw(7)
          end
          i6 = 0
          pos6 = nil
          p_loc6 = nil
          n6 = nil
          catch(9) do
            pos6 = @position_offset
            p_loc6 = @position_offset_loc
            n6 = answer.thunks.length
            q8 = @position_offset
            q_loc8 = @position_offset_loc
            m8 = answer.thunks.length
            i8 = 0
            pos8 = nil
            p_loc8 = nil
            n8 = nil
            catch(10) do
              pos8 = @position_offset
              p_loc8 = @position_offset_loc
              n8 = answer.thunks.length
              if (
                refill_buffer(1) < 1 ||
                @buffer[@position_offset] != "_"
              )
                throw(10)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
              @position_offset += 1
              i8 += 1
              if @position_offset != pos8
                redo
              end
              pos8 = nil
            end
            if pos8
              @position_offset = pos8
              @position_offset_loc = p_loc8
              answer.thunks[n8..-1] = []
            end
            if i8 < 1
              @position_offset = q8
              @position_offset_loc = q_loc8
              answer.thunks[m8..-1] = []
              throw(9)
            end
            q8 = @position_offset
            q_loc8 = @position_offset_loc
            m8 = answer.thunks.length
            i8 = 0
            pos8 = nil
            p_loc8 = nil
            n8 = nil
            catch(11) do
              pos8 = @position_offset
              p_loc8 = @position_offset_loc
              n8 = answer.thunks.length
              if refill_buffer(1) < 1
                throw(11)
              end
              u9 = @buffer[@position_offset]
              if (!(
                u9 == "_" ||
                (u9 >= "0" && u9 <= "7")
              ))
                throw(11)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
              @position_offset += 1
              i8 += 1
              if @position_offset != pos8
                redo
              end
              pos8 = nil
            end
            if pos8
              @position_offset = pos8
              @position_offset_loc = p_loc8
              answer.thunks[n8..-1] = []
            end
            if i8 < 1
              @position_offset = q8
              @position_offset_loc = q_loc8
              answer.thunks[m8..-1] = []
              throw(9)
            end
            i6 += 1
            if @position_offset != pos6
              redo
            end
            pos6 = nil
          end
          if pos6
            @position_offset = pos6
            @position_offset_loc = p_loc6
            answer.thunks[n6..-1] = []
          end
          q4 = @position_offset
          capt4 = answer.capts[1]
          capt4.range_start = pos4
          capt4.range_end = q4
          q_loc4 = @position_offset_loc
          capt4.start_loc = p_loc4
          capt4.end_loc = q_loc4
          answer.thunks.push(
            ThunkLeaf.new(
              :action_tINTEGER_1,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              {},
              answer.capts.slice(1),
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(12) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@position_offset] != "0"
          )
            throw(12)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
          @position_offset += 1
          if refill_buffer(1) < 1
            throw(12)
          end
          u4 = @buffer[@position_offset]
          if (!(
            u4 == "B" ||
            u4 == "b"
          ))
            throw(12)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
          @position_offset += 1
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          q6 = @position_offset
          q_loc6 = @position_offset_loc
          m6 = answer.thunks.length
          i6 = 0
          pos6 = nil
          p_loc6 = nil
          n6 = nil
          catch(13) do
            pos6 = @position_offset
            p_loc6 = @position_offset_loc
            n6 = answer.thunks.length
            if refill_buffer(1) < 1
              throw(13)
            end
            u7 = @buffer[@position_offset]
            if (!(
              u7 == "0" ||
              u7 == "1"
            ))
              throw(13)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
            @position_offset += 1
            i6 += 1
            if @position_offset != pos6
              redo
            end
            pos6 = nil
          end
          if pos6
            @position_offset = pos6
            @position_offset_loc = p_loc6
            answer.thunks[n6..-1] = []
          end
          if i6 < 1
            @position_offset = q6
            @position_offset_loc = q_loc6
            answer.thunks[m6..-1] = []
            throw(12)
          end
          i6 = 0
          pos6 = nil
          p_loc6 = nil
          n6 = nil
          catch(14) do
            pos6 = @position_offset
            p_loc6 = @position_offset_loc
            n6 = answer.thunks.length
            q8 = @position_offset
            q_loc8 = @position_offset_loc
            m8 = answer.thunks.length
            i8 = 0
            pos8 = nil
            p_loc8 = nil
            n8 = nil
            catch(15) do
              pos8 = @position_offset
              p_loc8 = @position_offset_loc
              n8 = answer.thunks.length
              if (
                refill_buffer(1) < 1 ||
                @buffer[@position_offset] != "_"
              )
                throw(15)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
              @position_offset += 1
              i8 += 1
              if @position_offset != pos8
                redo
              end
              pos8 = nil
            end
            if pos8
              @position_offset = pos8
              @position_offset_loc = p_loc8
              answer.thunks[n8..-1] = []
            end
            if i8 < 1
              @position_offset = q8
              @position_offset_loc = q_loc8
              answer.thunks[m8..-1] = []
              throw(14)
            end
            q8 = @position_offset
            q_loc8 = @position_offset_loc
            m8 = answer.thunks.length
            i8 = 0
            pos8 = nil
            p_loc8 = nil
            n8 = nil
            catch(16) do
              pos8 = @position_offset
              p_loc8 = @position_offset_loc
              n8 = answer.thunks.length
              if refill_buffer(1) < 1
                throw(16)
              end
              u9 = @buffer[@position_offset]
              if (!(
                u9 == "_" ||
                u9 == "0" ||
                u9 == "1"
              ))
                throw(16)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
              @position_offset += 1
              i8 += 1
              if @position_offset != pos8
                redo
              end
              pos8 = nil
            end
            if pos8
              @position_offset = pos8
              @position_offset_loc = p_loc8
              answer.thunks[n8..-1] = []
            end
            if i8 < 1
              @position_offset = q8
              @position_offset_loc = q_loc8
              answer.thunks[m8..-1] = []
              throw(14)
            end
            i6 += 1
            if @position_offset != pos6
              redo
            end
            pos6 = nil
          end
          if pos6
            @position_offset = pos6
            @position_offset_loc = p_loc6
            answer.thunks[n6..-1] = []
          end
          q4 = @position_offset
          capt4 = answer.capts[2]
          capt4.range_start = pos4
          capt4.range_end = q4
          q_loc4 = @position_offset_loc
          capt4.start_loc = p_loc4
          capt4.end_loc = q_loc4
          answer.thunks.push(
            ThunkLeaf.new(
              :action_tINTEGER_2,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              {},
              answer.capts.slice(2),
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(17) do
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          n4 = answer.thunks.length
          catch(19) do
            catch(18) do
              if (
                refill_buffer(1) < 1 ||
                @buffer[@position_offset] != "0"
              )
                throw(18)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
              @position_offset += 1
              if refill_buffer(1) < 1
                throw(18)
              end
              u6 = @buffer[@position_offset]
              if (!(
                u6 == "D" ||
                u6 == "d"
              ))
                throw(18)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
              @position_offset += 1
              throw(19)
            end
            @position_offset_loc = p_loc4
            @position_offset = pos4
            answer.thunks[n4..-1] = []
          end
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          q6 = @position_offset
          q_loc6 = @position_offset_loc
          m6 = answer.thunks.length
          i6 = 0
          pos6 = nil
          p_loc6 = nil
          n6 = nil
          catch(20) do
            pos6 = @position_offset
            p_loc6 = @position_offset_loc
            n6 = answer.thunks.length
            if refill_buffer(1) < 1
              throw(20)
            end
            u7 = @buffer[@position_offset]
            if (!(
              (u7 >= "0" && u7 <= "9")
            ))
              throw(20)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
            @position_offset += 1
            i6 += 1
            if @position_offset != pos6
              redo
            end
            pos6 = nil
          end
          if pos6
            @position_offset = pos6
            @position_offset_loc = p_loc6
            answer.thunks[n6..-1] = []
          end
          if i6 < 1
            @position_offset = q6
            @position_offset_loc = q_loc6
            answer.thunks[m6..-1] = []
            throw(17)
          end
          i6 = 0
          pos6 = nil
          p_loc6 = nil
          n6 = nil
          catch(21) do
            pos6 = @position_offset
            p_loc6 = @position_offset_loc
            n6 = answer.thunks.length
            q8 = @position_offset
            q_loc8 = @position_offset_loc
            m8 = answer.thunks.length
            i8 = 0
            pos8 = nil
            p_loc8 = nil
            n8 = nil
            catch(22) do
              pos8 = @position_offset
              p_loc8 = @position_offset_loc
              n8 = answer.thunks.length
              if (
                refill_buffer(1) < 1 ||
                @buffer[@position_offset] != "_"
              )
                throw(22)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
              @position_offset += 1
              i8 += 1
              if @position_offset != pos8
                redo
              end
              pos8 = nil
            end
            if pos8
              @position_offset = pos8
              @position_offset_loc = p_loc8
              answer.thunks[n8..-1] = []
            end
            if i8 < 1
              @position_offset = q8
              @position_offset_loc = q_loc8
              answer.thunks[m8..-1] = []
              throw(21)
            end
            q8 = @position_offset
            q_loc8 = @position_offset_loc
            m8 = answer.thunks.length
            i8 = 0
            pos8 = nil
            p_loc8 = nil
            n8 = nil
            catch(23) do
              pos8 = @position_offset
              p_loc8 = @position_offset_loc
              n8 = answer.thunks.length
              if refill_buffer(1) < 1
                throw(23)
              end
              u9 = @buffer[@position_offset]
              if (!(
                (u9 >= "0" && u9 <= "9")
              ))
                throw(23)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
              @position_offset += 1
              i8 += 1
              if @position_offset != pos8
                redo
              end
              pos8 = nil
            end
            if pos8
              @position_offset = pos8
              @position_offset_loc = p_loc8
              answer.thunks[n8..-1] = []
            end
            if i8 < 1
              @position_offset = q8
              @position_offset_loc = q_loc8
              answer.thunks[m8..-1] = []
              throw(21)
            end
            i6 += 1
            if @position_offset != pos6
              redo
            end
            pos6 = nil
          end
          if pos6
            @position_offset = pos6
            @position_offset_loc = p_loc6
            answer.thunks[n6..-1] = []
          end
          q4 = @position_offset
          capt4 = answer.capts[3]
          capt4.range_start = pos4
          capt4.range_end = q4
          q_loc4 = @position_offset_loc
          capt4.start_loc = p_loc4
          capt4.end_loc = q_loc4
          answer.thunks.push(
            ThunkLeaf.new(
              :action_tINTEGER_3,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              {},
              answer.capts.slice(3),
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   tINTEGER #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH tINTEGER #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_tIDENTIFIER(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    tIDENTIFIER #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      if refill_buffer(1) < 1
        throw(0)
      end
      u3 = @buffer[@position_offset]
      if (!(
        (u3 >= "a" && u3 <= "z") ||
        u3 == "_"
      ))
        throw(0)
      end
      @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
      @position_offset += 1
      i3 = 0
      pos3 = nil
      p_loc3 = nil
      n3 = nil
      catch(1) do
        pos3 = @position_offset
        p_loc3 = @position_offset_loc
        n3 = answer.thunks.length
        if refill_buffer(1) < 1
          throw(1)
        end
        u4 = @buffer[@position_offset]
        if (!(
          (u4 >= "a" && u4 <= "z") ||
          (u4 >= "A" && u4 <= "Z") ||
          u4 == "_" ||
          (u4 >= "0" && u4 <= "9")
        ))
          throw(1)
        end
        @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
        @position_offset += 1
        i3 += 1
        if @position_offset != pos3
          redo
        end
        pos3 = nil
      end
      if pos3
        @position_offset = pos3
        @position_offset_loc = p_loc3
        answer.thunks[n3..-1] = []
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_tIDENTIFIER_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          {},
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   tIDENTIFIER #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH tIDENTIFIER #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_tCONSTANT(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    tCONSTANT #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      if refill_buffer(1) < 1
        throw(0)
      end
      u3 = @buffer[@position_offset]
      if (!(
        (u3 >= "A" && u3 <= "Z")
      ))
        throw(0)
      end
      @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
      @position_offset += 1
      i3 = 0
      pos3 = nil
      p_loc3 = nil
      n3 = nil
      catch(1) do
        pos3 = @position_offset
        p_loc3 = @position_offset_loc
        n3 = answer.thunks.length
        if refill_buffer(1) < 1
          throw(1)
        end
        u4 = @buffer[@position_offset]
        if (!(
          (u4 >= "a" && u4 <= "z") ||
          (u4 >= "A" && u4 <= "Z") ||
          u4 == "_" ||
          (u4 >= "0" && u4 <= "9")
        ))
          throw(1)
        end
        @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
        @position_offset += 1
        i3 += 1
        if @position_offset != pos3
          redo
        end
        pos3 = nil
      end
      if pos3
        @position_offset = pos3
        @position_offset_loc = p_loc3
        answer.thunks[n3..-1] = []
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_tCONSTANT_0,
          Capture.new(
            answer.pos, @position_offset,
            answer.pos_loc, @position_offset_loc,
          ),
          {},
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   tCONSTANT #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH tCONSTANT #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_term(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    term #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      catch(1) do
        pos2 = @position_offset
        p_loc2 = @position_offset_loc
        n2 = answer.thunks.length
        catch(2) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@position_offset] != ";"
          )
            throw(2)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
          @position_offset += 1
          answer.thunks.push(
            ThunkLeaf.new(
              :action_term_0,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              {},
              {},
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(3) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@position_offset] != "\n"
          )
            throw(3)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
          @position_offset += 1
          answer.thunks.push(
            ThunkLeaf.new(
              :action_term_1,
              Capture.new(
                answer.pos, @position_offset,
                answer.pos_loc, @position_offset_loc,
              ),
              {},
              {},
            )
          )
          throw(1)
        end
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   term #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH term #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_spaces(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    spaces #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      q2 = @position_offset
      q_loc2 = @position_offset_loc
      m2 = answer.thunks.length
      i2 = 0
      pos2 = nil
      p_loc2 = nil
      n2 = nil
      catch(1) do
        pos2 = @position_offset
        p_loc2 = @position_offset_loc
        n2 = answer.thunks.length
        if refill_buffer(1) < 1
          throw(1)
        end
        u3 = @buffer[@position_offset]
        if (!(
          u3 == " " ||
          u3 == "\t" ||
          u3 == "\v" ||
          u3 == "\f" ||
          u3 == "\r"
        ))
          throw(1)
        end
        @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
        @position_offset += 1
        i2 += 1
        if @position_offset != pos2
          redo
        end
        pos2 = nil
      end
      if pos2
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
      end
      if i2 < 1
        @position_offset = q2
        @position_offset_loc = q_loc2
        answer.thunks[m2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   spaces #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH spaces #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def evaluate_rule_EOF(offset, offset_loc, limits: nil)
    answer = ThunkChunk.new
    answer.pos = @position_offset
    answer.pos_loc = @position_offset_loc
    debug { warn "#{ "  " * @level}EVAL    EOF #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      if refill_buffer(1) >= 1
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   EOF #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH EOF #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
    return nil
  end

  def grow_lr(rule, offset, offset_loc)
    while true
      old_offset = @position_offset
      @position_offset = offset
      @position_offset_loc = offset_loc
      answer = public_send(rule, offset, offset_loc, limits: {rule => true})
      if !answer || @position_offset <= old_offset
        break
      end
      memo = @memos[offset, rule]
      memo.answer = answer
      memo.offset = @position_offset
      memo.offset_loc = @position_offset_loc
    end
  end

  def rule_answer(rule)
    offset = @position_offset
    offset_loc = @position_offset_loc
    memo = @memos[offset, rule]

    if !memo
      memo = LrMemo.new(offset, offset_loc)
      @memos[offset, rule] = memo
      answer = public_send(rule, offset, offset_loc)
      memo.answer = answer
      memo.offset = @position_offset
      memo.offset_loc = @position_offset_loc
      if memo.grow
        grow_lr(rule, offset, offset_loc)
        memo.grow = false
        answer = memo.answer
        @position_offset = memo.offset
        @position_offset_loc = memo.offset_loc
      end
      return answer
    elsif memo.fail
      memo.answer = nil
      memo.grow = true
      return nil
    else
      @position_offset = memo.offset
      @position_offset_loc = memo.offset_loc
      return memo.answer
    end
  end

  def apply_rule(rule, thunks, values, index, offset, offset_loc, limits: nil)
    if limits
      limits = limits.merge(rule => true)
      answer = public_send(rule, offset, offset_loc, limits: limits)
      memo = @memos[offset, rule]
      if !answer || @position_offset <= memo.offset
        if memo
          answer = memo.answer
          @position_offset = memo.offset
          @position_offset_loc = memo.offset_loc
        end
      else
        memo.answer = answer
        memo.offset = @position_offset
        memo.offset_loc = @position_offset_loc
      end
    else
      answer = rule_answer(rule)
    end

    if !answer
      return false
    end
    values ||= @global_values
    thunks << ThunkNode.new(answer.thunks, values, index)
    return true
  end

  def do_action(thunks, values, index)
    thunks.each do |thunk|
      thunk.do_action(self, values, index)
    end
  end

  class LrMemoTable
    def initialize
      @memos = {}
    end

    def clear
      @memos.clear
    end

    def []=(index, rule_name, memo)
      entry = @memos[index] ||= {}
      entry[rule_name] = memo
    end

    def [](index, rule_name)
      @memos.dig(index, rule_name)
    end
  end

  class LrMemo
    attr_accessor :grow, :answer, :offset, :fail
    attr_accessor :offset_loc

    def initialize(offset, offset_loc)
      @offset = offset
      @offset_loc = offset_loc
      @fail = true
      @grow = false
    end

    def answer=(answer)
      @fail = nil
      @answer = answer
    end
  end

  class ThunkChunk
    attr_accessor :thunks, :capts, :pos, :values
    attr_accessor :pos_loc

    def initialize
      super
      @thunks = []
      @capts = {}
      @pos = 0
      @values = {}
    end

    def resize_captures(len)
      len.times do |i|
        @capts[i] = Capture.new
      end
    end
  end

  class ThunkLeaf
    attr_accessor :capt0, :capts, :value_refs, :action

    def initialize(action, capt0 = Capture.new, value_refs = {}, capts = {})
      @value_refs = value_refs
      @capts = capts
      @capt0 = capt0
      @action = action
    end

    def do_action(ctx, values, index)
      ctx.public_send(action, self, values, index)
    end
  end

  class ThunkNode
    attr_accessor :thunks, :values, :index

    def initialize(thunks, values, index)
      @thunks = thunks
      @values = values
      @index = index
      values[index] ||= Value.new if values
    end

    def do_action(ctx, _values, _index)
      @thunks.each do |thunk|
        thunk.do_action(ctx, @values, @index)
      end
    end

    def clear
      @thunks.clear
    end
  end

  class Capture
    attr_accessor :range_start, :range_end
    attr_accessor :start_loc, :end_loc

    def initialize(range_start = 0, range_end = 0, start_loc = nil, end_loc = nil)
      @range_start = range_start
      @range_end = range_end
      @start_loc = start_loc || Location.new
      @end_loc = end_loc || Location.new
    end

    def capture_string(buffer)
      @capture_string ||= buffer[@range_start, @range_end - @range_start]
    end
  end

  class Value
    attr_accessor :value
  end
end

if ENV["MAKE"] == "1"
  require "mkmf"
  create_makefile("tiny_ruby_parser")
  system("make", out: :err) || raise
  exit
end
if ENV["EXT"] == "1"
  require "tiny_ruby_parser.so"
end
if ARGV[0]
  require "stringio"
  str = ARGV[0]
  $stdin = StringIO.new("#{str}\n", "r")
end
TinyRubyParser.new().run
